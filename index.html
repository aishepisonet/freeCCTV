
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>IPTV Player</title>

  <!-- hls.js for .m3u8 -->
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>

  
<!-- Use a specific version instead of 'latest' -->
<script src="https://cdn.dashjs.org/v4.7.4/dash.all.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/dashjs/4.7.4/dash.all.min.js"></script>


 <script src="https://cdn.jsdelivr.net/npm/shaka-player@4.16.12/dist/shaka-player.compiled.min.js"></script>

  <style>
    /* Reset and base */
    * { box-sizing: border-box; }
    body, html {
      margin: 0; padding: 0; height: 100%;
      font-family: Arial, sans-serif;
      background: #111;
      color: #eee;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    /* Container holding player and channels */
    #main-content {
      flex: 1 1 auto;
      display: flex;
      flex-direction: row; /* desktop: player left, channels right */
      overflow: hidden;
      padding: 10px;
      max-width: 1200px;
      margin: 0 auto;
      gap: 10px;
    }

    /* Player container */
    #video-container {
      flex: 0 0 80%; /* 80% width for player */
      max-width: 80%;
      overflow: hidden;
      position: relative;
    }

    #channel-name {
      font-size: 1.3rem;
      font-weight: 700;
      margin-bottom: 10px;
      text-align: center;
      color: #00bfff;
    }

    /* Keep a consistent 16:9 area */
    #videoWrapper {
      width: 100%;
      aspect-ratio: 16 / 9;
      background: black;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
    }

    #videoWrapper iframe,
    #videoWrapper video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      background: black;
      display: block;
    }

    /* Hide native time display and create custom one */
#videoWrapper {
    position: relative;
}

.custom-time-display {
    position: absolute;
    bottom: 50px;
    right: 10px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 14px;
    z-index: 1000;
    display: none;
}

/* Show custom time display when video has focus */
video:focus + .custom-time-display,
.video-wrapper:hover .custom-time-display {
    display: block;
}
/* Add this to your CSS */
#videoWrapper {
    position: relative;
}

/* Hide native controls time display for live streams */
.shaka-video::-webkit-media-controls-timeline,
.shaka-video::-webkit-media-controls-current-time-display,
.shaka-video::-webkit-media-controls-time-remaining-display {
    display: none !important;
}

/* For Firefox and other browsers */
.shaka-video::-moz-range-track {
    display: none;
}

/* Custom controls styling */
#custom-time-display {
    font-family: 'Arial', sans-serif;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
}

#live-stream-controls {
    opacity: 0;
    transition: opacity 0.3s ease;
}

/* Fullscreen styles */
#videoWrapper:fullscreen {
    width: 100vw;
    height: 100vh;
    background: #000;
}

#videoWrapper:fullscreen video {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

/* Enhanced Controls Styling for DASH */
#custom-controls {
    position: absolute;
    bottom: 20px;
    right: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
    z-index: 1000;
    pointer-events: none;
    transition: all 0.3s ease;
    opacity: 20;
}

#live-indicator {
    background: rgba(255, 50, 50, 0.9);
    color: white;
    padding: 6px 12px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: bold;
    font-family: Arial, sans-serif;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    pointer-events: none;
    transition: all 0.3s ease;
}

#fullscreen-btn {
    background: rgba(0, 0, 0, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: white;
    width: 36px;
    height: 36px;
    border-radius: 8px;
    font-size: 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(10px);
    pointer-events: auto;
    transition: all 0.2s ease;
}

#fullscreen-btn:hover {
    background: rgba(0, 0, 0, 0.9);
    border-color: rgba(255, 255, 255, 0.6);
    transform: scale(1.05);
}

/* Fullscreen enhancements */
#videoWrapper:fullscreen {
    width: 100vw;
    height: 100vh;
    background: #000;
    display: flex;
    align-items: center;
    justify-content: center;
}

#videoWrapper:fullscreen video {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

#videoWrapper:fullscreen #custom-controls {
    bottom: 40px;
    right: 40px;
    opacity: 1 !important;
}

/* Video focus styles for keyboard controls */
video:focus {
    outline: 2px solid #fff;
    outline-offset: 2px;
}


    /* Quality selector */
    #qualitySelector {
      position: absolute;
      right: 12px;
      top: 12px;
      z-index: 8;
      background: rgba(0,0,0,0.6);
      color: #fff;
      border: 1px solid #666;
      border-radius: 6px;
      padding: 4px;
      font-size: 0.9rem;
      display: none !important;

    }

    /* Channel list container - desktop */
    #channel-list {
      flex: 0 0 20%; /* 20% width for channels */
      max-width: 20%;
      display: grid;
      grid-template-columns: 1fr 1fr; /* 2 columns desktop */
      gap: 6px; /* desktop gap between items */
      padding: 10px;
      background: #222;
      border-radius: 8px;
      overflow-y: auto; /* scroll if content too tall */
      max-height: calc(100vh - 20px); /* avoid exceeding viewport */
    }

    /* Modern scrollbar for desktop */
    #channel-list::-webkit-scrollbar {
      width: 8px;
    }
    #channel-list::-webkit-scrollbar-track {
      background: #111;
      border-radius: 4px;
    }
    #channel-list::-webkit-scrollbar-thumb {
      background: #00bfff;
      border-radius: 4px;
    }
    #channel-list {
      scrollbar-width: thin;
      scrollbar-color: #00bfff #111;
    }

    /* Individual channels - logo fills container */
    .channel {
      width: 100%;
      aspect-ratio: 1; /* ensures square container */
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      border-radius: 8px;
      border: 2px solid transparent;
      background: #333;
      transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease;
    }

    .channel img {
      width: 90%;      /* fill most of square container */
      height: 90%;
      object-fit: contain; /* keep logo ratio */
      border-radius: 6px;
      filter: brightness(0.85);
      transition: filter 0.3s ease;
    }

    .channel span {
      display: block;
      font-size: 11px;
      margin-top: 2px;
      color: #ddd;
      text-align: center;
    }

    .channel:hover img { filter: brightness(1); }
    .channel.active { border-color: #00bfff; transform: scale(1.06); background: #005f9e; }
    .channel.active img { filter: brightness(1); }

    /* Footer */
    footer {
      flex-shrink: 0;
      background: #111;
      color: #666;
      font-size: 0.85rem;
      text-align: center;
      padding: 12px 15px;
      border-top: 1px solid #222;
      user-select: none;
    }

    /* Loader */
    .loader {
      position: absolute;
      left: 50%; top: 50%;
      width: 54px; height: 54px;
      margin-left: -27px; margin-top: -27px;
      border: 6px solid rgba(255,255,255,0.25);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 0.9s linear infinite;
      display: none;
      z-index: 5;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* #unmuteBtn {
      position: absolute;
      left: 12px; bottom: 12px;
      z-index: 6;
      background: rgba(0,0,0,0.6);
      color: #fff;
      border: 1px solid #666;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 0.9rem;
      display: none;
      cursor: pointer;
    } */

    /* Responsive: tablets and mobiles */
    @media (max-width: 900px) {
      #main-content {
        flex-direction: column; /* stack vertically */
      }

      /* Player full width */
      #video-container {
        flex: 0 0 auto;
        width: 100%;
        max-width: 100%;
        margin-bottom: 6px;
      }

      #videoWrapper {
        width: 100%;
        max-width: 100%;
        aspect-ratio: 16 / 9; /* maintain ratio */
      }

      /* Channel list: horizontal scroll, 6 visible items */
      #channel-list {
        flex: 0 0 auto;
        width: 100%;
        max-width: 100%;
        display: flex;
        gap: 4px;
        padding: 6px 4px;
        overflow-x: auto;
        overflow-y: hidden;
        scroll-snap-type: x mandatory;
        -webkit-overflow-scrolling: touch;
      }

      #channel-list .channel {
        flex: 0 0 auto;
        width: calc((100% / 6) - 4px); /* 6 items visible */
        aspect-ratio: 1;
        scroll-snap-align: start;
        max-height: 60px;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      #channel-list .channel img {
        width: 90%;
        height: 90%;
      }

      /* Scrollbar for mobile */
      #channel-list::-webkit-scrollbar {
        height: 6px;
      }
      #channel-list::-webkit-scrollbar-thumb {
        background: #00bfff;
        border-radius: 3px;
      }
      #channel-list::-webkit-scrollbar-track {
        background: #111;
      }
    }

    @media (max-width: 400px) {
      #channel-list {
        gap: 3px;
        padding: 4px 6px;
      }
      #channel-list .channel {
        width: calc((100% / 6) - 3px);
        max-height: 50px;
      }
      .channel img {
        width: 90%;
        height: 90%;
      }
      #channel-name {
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <div id="main-content">
    <div id="video-container">
      <div id="channel-name">Loading...</div>

        <div id="videoWrapper">
         Players injected here 
        <div class="loader" id="loader"></div>
        <button id="unmuteBtn" type="button">Tap to Unmute</button>
        <select id="qualitySelector" aria-label="Quality selector"></select>
         <div id="custom-controls" style="display: none;">
         <!-- <div id="live-indicator">‚óè LIVE</div> -->
         <button id="fullscreen-btn">‚õ∂</button>
        </div>
      </div>
    </div> 

    <div id="channel-list"></div>
  </div>

  <footer>
    <strong>DISCLAIMER:</strong> We do not host any channels. All links are gathered from
      <a href="https://iptv-org.github.io/" target="_blank" rel="noopener noreferrer">iptv-org</a> and YouTube online streaming.
  </footer>

  <script>
    // -------------------------
    // Channel List (embedded in script)
    // -------------------------
    const channels = [

      {
        name: "A2Z HD",
        logo: "https://i.pinimg.com/736x/18/86/a4/1886a48723fc3ac50314ea15ca9be3b2.jpg",
        type: "mpd",
        link: "https://d1uf7s78uqso1e.cloudfront.net/out/v1/efa01372657648be830e7c23ff68bea2/index.mpd",
        drmtype: "clearkey",
        clearkey: {'f703e4c8ec9041eeb5028ab4248fa094': 'c22f2162e176eee6273a5d0b68d19530'
        },
        isLive: true
        },
        {
        name: "A2Z SD", 
        logo: "https://i.pinimg.com/736x/18/86/a4/1886a48723fc3ac50314ea15ca9be3b2.jpg",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-02-prod.akamaized.net/bpk-tv/cg_a2z/default/index.mpd",
        drmtype: "clearkey",
        clearkey: {'f703e4c8ec9041eeb5028ab4248fa094': 'c22f2162e176eee6273a5d0b68d19530'
        },
        isLive: true
        },
        { 
            name: "AMC Thrillers", 
            logo: "https://i.imgur.com/EVD0aIt.png", 
            type: "m3u8", 
            link: "https://amc-rushbyamc-1-us.vizio.wurl.tv/playlist.m3u8" 
        },
        {
        name: "ANC", 
        logo: "https://upload.wikimedia.org/wikipedia/commons/b/b4/ANClogo2014.svg",
        type: "mpd",
        link: "https://cdn-ue1-prod.tsv2.amagi.tv/linear/amg01006-abs-cbn-anc-global-dash-abscbnono/index.mpd",
        drmtype: "clearkey",
        clearkey: {'4bbdc78024a54662854b412d01fafa16': '6039ec9b213aca913821677a28bd78ae'
        },
        isLive: true
        },
        {
        name: "Animax", 
        logo: "https://i.pinimg.com/736x/20/f0/9f/20f09f88d5b2db549ca0c686f2c6323f.jpg",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-01-prod.akamaized.net/bpk-tv/cg_animax_sd_new/default/index.mpd",
        drmType: "clearkey",
        clearkey: {'92032b0e41a543fb9830751273b8debd': '03f8b65e2af785b10d6634735dbe6c11'
        },
        isLive: true
        },
        {
        name: "AXN", 
        logo: "https://divign0fdw3sv.cloudfront.net/Images/ChannelLogo/contenthub/131_144.png",
        type: "mpd",
        link: "https://qp-pldt-live-grp-06-prod.akamaized.net/out/u/cg_axn_sd.mpd",
        drmType: "clearkey",
        clearkey: {'fd5d928f5d974ca4983f6e9295dfe410': '3aaa001ddc142fedbb9d5557be43792f'
        },
        isLive: true
        },
        {
        name: "Bilyonaryo News Channel", 
        logo: "https://static.wikia.nocookie.net/logopedia/images/5/56/Img_1_1756009833117.jpg",
        type: "mpd",
        link: "https://linearjitp-playback.astro.com.my/dash-wv/linear/2303/default_ott.mpd",
        drmType: "clearkey",
        clearkey: {'227ffaf09bec4a889e0e0988704d52a2': 'b2d0dce5c486891997c1c92ddaca2cd2'
        },
        isLive: true
        },
        {
        name: "BUKO", 
        logo:"https://i.imgur.com/Wv0K5Yc.png",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-01-prod.akamaized.net/bpk-tv/cg_buko_sd/default/index.mpd",
        drmType: "clearkey",
        clearkey: {'d273c085f2ab4a248e7bfc375229007d': '7932354c3a84f7fc1b80efa6bcea0615'
        },
        isLive: true
        },
        {
        name: "Cartoon Network", 
        logo: "https://poster.starhubgo.com/Linear_channels2/316_1920x1080_HTV.png",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-02-prod.akamaized.net/bpk-tv/cartoonnetworkhd/default/index.mpd",
        drmType: "clearkey",
        clearkey: {'a2d1f552ff9541558b3296b5a932136b': 'cdd48fa884dc0c3a3f85aeebca13d444'
        },
        isLive: true
        },
         {
        name: "Cinema One",
        logo: "https://upload.wikimedia.org/wikipedia/commons/6/66/Cinema_One_logo.png",
        type: "mpd",
        link: "https://live-faws.akamaized.net/out/v1/93b9db7b231d45f28f64f29b86dc6c65/index.mpd",
        //licenseServer: "https://d9rpesrrg1bdi.cloudfront.net",
        isLive: true // Explicitly mark as live
        },
        {
        name: "CINEMO",
        logo: "https://upload.wikimedia.org/wikipedia/commons/4/41/Cinemologo.png",
        type: "mpd",
        link: "https://live-faws.akamaized.net/out/v1/3a895f368f4a467c9bca0962559efc19/index.mpd",
        //licenseServer: "http://143.44.136.74:9443/widevine/?deviceId=02:00:00:00:00:00",
        isLive: true // Explicitly mark as live
        },
        {
        name: "CNN Philippines", 
        logo: "https://i.imgur.com/JOg1GGl.png",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-02-prod.akamaized.net/bpk-tv/cg_cnnhd/default/index.mpd",
        drmType: "clearkey",
        clearkey: {'900c43f0e02742dd854148b7a75abbec': 'da315cca7f2902b4de23199718ed7e90'
        },
        isLive: true
        },
        {
        name: "Disney Channel", 
        logo: "https://www.hollywoodreporter.com/wp-content/uploads/2014/05/disney_channel_logo_a_l.jpg",
        type: "mpd",
        link: "https://ottb.live.cf.ww.aiv-cdn.net/dub-nitro/live/clients/dash/enc/zuf794yutz/out/v1/ca3534bfe4f148298b36719204d108e0/cenc.mpd",
        clearkey: {'be9caaa813c5305e761c66ac63645901': '3d40f2990ec5362ca5be3a3c9bb8f8b4'
        },
        isLive: true
        },
        {
        name: "DreamWorks", 
        logo: "https://i.imgur.com/cgfKSDP.png",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-02-prod.akamaized.net/bpk-tv/cg_dreamworks_hd1/default/index.mpd",
        drmType: "clearkey",
        clearkey: {'4ab9645a2a0a47edbd65e8479c2b9669': '8cb209f1828431ce9b50b593d1f44079'
        },
        isLive: true
        },
        { 
        name: "Eat Bulaga TVJ", 
        logo: "https://yt3.googleusercontent.com/LEJiad-8tC5St_L8zMg-jWvZYUD9dYJ2g539wqlRCxpepPi9JgQWRbattOy3aSUh_3PPWcSc=s160-c-k-c0x00ffffff-no-rj", 
        type: "youtube", 
        link: "https://www.youtube.com/embed/live_stream?channel=UCby04dl3oIxkDoZil8xP_FA&autoplay=1" 
        },
        {
        name: "GMA",
        logo: "https://i.pinimg.com/736x/c7/bc/0c/c7bc0cdaa2c3e5b02ceb374fa2282cf2.jpg",
        type: "mpd",
        link: "https://cdn-uw2-prod.tsv2.amagi.tv/linear/amg01006-abs-cbn-abscbn-gma-x7-dash-abscbnono/7c693236-e0c1-40a3-8bd0-bb25e43f5bfc/index.mpd",
        //licenseServer: "http://143.44.136.74:9443/widevine/?deviceId=02:00:00:00:00:00",
        isLive: true // Explicitly mark as live
        },
        {
        name: "HBO HD", 
        logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/d/de/HBO_logo.svg/1920px-HBO_logo.svg.png",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-02-prod.akamaized.net/bpk-tv/cg_hbohd/default/index.mpd",
        drmType: "clearkey",
        clearkey: {'d47ebabf7a21430b83a8c4b82d9ef6b1': '54c213b2b5f885f1e0290ee4131d425b'
        },
        isLive: true
        },
        {
        name: "Jeepney TV",
        logo: "https://i.pinimg.com/736x/76/36/ea/7636ea0637bdbc796f54c8b7087c6805.jpg",
        type: "mpd",
        link: "https://abslive.akamaized.net/dash/live/2028025/jeepneytv/manifest.mpd",
        clearkey: {'90ea4079e02f418db7b170e8763e65f0': '1bfe2d166e31d03eee86ee568bd6c272'
        },
        isLive: true},
        { 
        name: "Kapamilya Online Live", 
        logo: "https://upload.wikimedia.org/wikipedia/en/f/f2/Kapamilya_Channel_Logo_2020.svg", 
        type: "youtube", 
        link: "https://www.youtube.com/embed/live_stream?channel=UCstEtN0pgOmCf02EdXsGChw&autoplay=1" 
        },
        {
        name: "Kapamilya Movie Channel", 
        logo: "https://i.pinimg.com/736x/bb/5a/c7/bb5ac7de7e3e772e0e098637fafd121a.jpg",
        type: "mpd",
        link: "https://cdn-ue1-prod.tsv2.amagi.tv/linear/amg01006-abs-cbn-kapcha-dash-abscbnono/index.mpd",
        drmType: "clearkey",
        clearkey: {'bd17afb5dc9648a39be79ee3634dd4b8': '3ecf305d54a7729299b93a3d69c02ea5'
        },
        isLive: true
        },
        { 
        name: "Kapuso Stream", 
        logo: "https://upload.wikimedia.org/wikipedia/commons/6/65/Kapuso_Stream_logo.png", 
        type: "youtube", 
        link: "https://www.youtube.com/embed/live_stream?channel=UCKL5hAuzgFQsyrsQKgU0Qng&autoplay=1" 
        },
        { 
        name: "Movie Sphere", 
        logo: "https://static-us-east-2-fastly-a.www.philo.com/images/channel_logos/MOVSPH/large_dark.png?auto=webp&ver=1", 
        type: "m3u8", 
        link: "https://moviesphereuk-samsunguk.amagi.tv/playlist.m3u8" 
        },
        {
        name: "NBA TV Philippines", 
        logo: "https://i.pinimg.com/736x/02/44/e3/0244e35a41fd5a4724406f5720fcc69f.jpg",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-02-prod.akamaized.net/bpk-tv/cgnl_nba/default/index.mpd",
        drmType: "clearkey",
        clearkey: {'c5e51f41ceac48709d0bdcd9c13a4d88': '20b91609967e472c27040716ef6a8b9a'
        },
        isLive: true},
        { 
        name: "NEW KPOP", 
        logo: "https://yt3.googleusercontent.com/ytc/AIdro_mvIHQlYealbOtnxSkoFhR5NOnjFiqr7vPRJHsn-dH0P-c=s160-c-k-c0x00ffffff-no-rj", 
        type: "m3u8", 
        link: "https://newidco-newkid-1-eu.xiaomi.wurl.tv/playlist.m3u8" 
        },
        { 
        name: "K-MOVIES", 
        logo: "https://i.imgur.com/Nd9gqA2.png", 
        type: "m3u8", 
        link: "https://7732c5436342497882363a8cd14ceff4.mediatailor.us-east-1.amazonaws.com/v1/master/04fd913bb278d8775298c26fdca9d9841f37601f/Plex_NewMovies/playlist.m3u8"
        },
        {
        name: "ONE Ph", 
        logo: "https://i.imgur.com/gkluDe9.png",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-02-prod.akamaized.net/bpk-tv/oneph_sd/default/index.mpd",
        drmType: "clearkey",
        clearkey: {'92834ab4a7e1499b90886c5d49220e46:': 'a7108d9a6cfcc1b7939eb111daf09ab3'
        },
        isLive: true
        },
        {
        name: "One Sports", 
        logo: "https://upload.wikimedia.org/wikipedia/commons/thumb/9/9c/One_Sports_logo.svg/2560px-One_Sports_logo.svg.png",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-02-prod.akamaized.net/bpk-tv/cg_onesports_hd/default/index.mpd",
        drmType: "clearkey",
        clearkey: {'53c3bf2eba574f639aa21f2d4409ff11': '3de28411cf08a64ea935b9578f6d0edd'
        },
        isLive: true
        },
        {
        name: "PBA Rush", 
        logo: "https://i.imgur.com/F2npB7o.png",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-02-prod.akamaized.net/bpk-tv/cg_pbarush_hd1/default/index.mpd",
        drmType: "clearkey",
        clearkey: {'76dc29dd87a244aeab9e8b7c5da1e5f3': '95b2f2ffd4e14073620506213b62ac82'
        },
        isLive: true
        },
        {
        name: "PBO", 
        logo: "https://i.imgur.com/r3PUF9p.png",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-01-prod.akamaized.net/bpk-tv/pbo_sd/default/index.mpd",
        drmType: "clearkey",
        clearkey: {'dcbdaaa6662d4188bdf97f9f0ca5e830': '31e752b441bd2972f2b98a4b1bc1c7a1'
        },
        isLive: true
        },
        {
        name: "RPTV", 
        logo: "https://i.pinimg.com/736x/1d/a0/d4/1da0d4ae8f1bdf5cfde95122b396263a.jpg",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-02-prod.akamaized.net/bpk-tv/cnn_rptv_prod_hd/default/index.mpd",
        drmType: "clearkey",
        clearkey: {'1917f4caf2364e6d9b1507326a85ead6': 'a1340a251a5aa63a9b0ea5d9d7f67595'
        },
        isLive: true
        },
        {
        name: "SARI SARI", 
        logo: "https://static.wikia.nocookie.net/russel/images/e/ec/Sari-Sari_Channel_2D_Logo_2016.png",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-02-prod.akamaized.net/bpk-tv/cg_sarisari/default/index.mpd",
        drmType: "clearkey",
        clearkey: {'0a7ab3612f434335aa6e895016d8cd2d': 'b21654621230ae21714a5cab52daeb9d'
        },
        isLive: true
        },
        { 
        name: "TV 5", 
        logo: "https://upload.wikimedia.org/wikipedia/commons/4/4f/TV5_%28Philippines%29_logo.svg", 
        type: "mpd", 
        link: "https://qp-pldt-live-bpk-02-prod.akamaized.net/bpk-tv/tv5_hd/default1/index.mpd",
        drmType: "clearkey",
        clearkey: {'2615129ef2c846a9bbd43a641c7303ef': '07c7f996b1734ea288641a68e1cfdc4d'
        },
        isLive: true 
        },
        {
        name: "tap SPORTS", 
        logo: "https://upload.wikimedia.org/wikipedia/en/6/6e/TAP_Sports_channel_logo.png",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-01-prod.akamaized.net/bpk-tv/dr_tapsports/default/index.mpd",
        drmType: "clearkey",
        clearkey: {'eabd2d95c89e42f2b0b0b40ce4179ea0': '0e7e35a07e2c12822316c0dc4873903f'
        },
        isLive: true
        },
        {
        name: "TMC", 
        logo: "https://i.imgur.com/550RYpJ.png",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-01-prod.akamaized.net/bpk-tv/cg_tagalogmovie/default/index.mpd",
        drmType: "clearkey",
        clearkey: {'96701d297d1241e492d41c397631d857': 'ca2931211c1a261f082a3a2c4fd9f91b'
        },
        isLive: true
        },
        {
        name: "TV Maria", 
        logo: "https://static.wikia.nocookie.net/logopedia/images/c/cd/TV_MARIA_PH.png",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-01-prod.akamaized.net/bpk-tv/tvmaria_prd/default/index.mpd",
        drmType: "clearkey",
        clearkey: {'fa3998b9a4de40659725ebc5151250d6': '998f1294b122bbf1a96c1ddc0cbb229f'
        },
        isLive: true
        },
        {
        name: "tvN", 
        logo: "https://i.imgur.com/eE9IBhJ.png",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-02-prod.akamaized.net/bpk-tv/cg_tvnpre/default/index.mpd",
        drmType: "clearkey",
        clearkey: {'e1bde543e8a140b38d3f84ace746553e': 'b712c4ec307300043333a6899a402c10'
        },
        isLive: true
        },
        {
        name: "tvN Movies Pinoy", 
        logo: "https://static.wikia.nocookie.net/russel/images/e/e3/TvN_Movies_Pinoy_Logo_2023.png",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-02-prod.akamaized.net/bpk-tv/cg_tvnmovie/default/index.mpd",
        drmType: "clearkey",
        clearkey: {'2e53f8d8a5e94bca8f9a1e16ce67df33': '3471b2464b5c7b033a03bb8307d9fa35'
        },
        isLive: true
        },
         {
        name: "TVN Premium", 
        logo: "https://i.imgur.com/gmM3ncL.png",
        type: "mpd",
        link: "https://qp-pldt-live-bpk-02-prod.akamaized.net/bpk-tv/cg_tvnpre/default/index.mpd",
        drmType: "clearkey",
        clearkey: { 'e1bde543e8a140b38d3f84ace746553e': 'b712c4ec307300043333a6899a402c10'
        },
        isLive: true
        },
        {
        name: "Warner TV", 
        logo: "https://ownassetsmysky.blob.core.windows.net/assetsmysky/production/plans-and-bundles/1599468004_warner-tv.gif",
        type: "mpd",
        link: "https://qp-pldt-live-grp-11-prod.akamaized.net/out/u/dr_warnertvhd.mpd",
        drmType: "clearkey",
        clearkey: {'4503cf86bca3494ab95a77ed913619a0': 'afc9c8f627fb3fb255dee8e3b0fe1d71'
        },
        isLive: true
        }
    ];

    // DOM refs
    const channelList = document.getElementById("channel-list");
    const channelName = document.getElementById("channel-name");
    const videoWrapper = document.getElementById("videoWrapper");
    const loader = document.getElementById("loader");
    const unmuteBtn = document.getElementById("unmuteBtn");
    const qualitySelector = document.getElementById("qualitySelector");
    

    // state
    let currentHls = null;
    let currentDash = null;
    let currentVideo = null;
    let currentShaka = null; // Add Shaka player instance


// ---------------------------
// Initialize channels with auto-play
// ---------------------------
function initializeChannels() {
    try {
        if (!Array.isArray(channels)) {
            throw new Error('Channels data is not a valid array');
        }
        
        console.log(`üì∫ Found ${channels.length} channels`);
        
        buildChannelList(channels);
        
        if (channels.length > 0) {
            // ‚úÖ AUTO-PLAY FIRST CHANNEL
            const firstChannel = channels[0];
            console.log('üé¨ Auto-playing first channel:', firstChannel.name);
            
            // Set channel name immediately
            channelName.textContent = firstChannel.name;
            
            // Small delay to ensure DOM is ready, then load channel
            setTimeout(() => {
                loadChannel(firstChannel);
            }, 500);
            
        } else {
            channelName.innerText = "No channels available";
            console.log('‚ùå No channels available for auto-play');
        }
        
    } catch (err) {
        console.error("Failed to initialize channels:", err);
        channelName.innerText = "Failed to load channels";
        
        channelList.innerHTML = `<div style="color: #ff6b6b; text-align: center; padding: 20px;">
            Error loading channels: ${err.message}
        </div>`;
    }
}

// ---------------------------
// Initialize Shaka Player (FIXED)
// ---------------------------
async function initializeShakaPlayer() {
    // Check if Shaka Player is available
    if (!window.shaka) {
        console.error('Shaka Player not loaded');
        return null;
    }
    
    // Install polyfills
    shaka.polyfill.installAll();
    
    // Create video element for Shaka
    const video = setupVideoElement();
    videoWrapper.appendChild(video);
    currentVideo = video;
    
    try {
        // Create Shaka Player instance
        const player = new shaka.Player(video);
        
        // Listen for errors
        player.addEventListener('error', (event) => {
            console.error('Shaka Player error:', event.detail);
        });
        
        return player;
    } catch (error) {
        console.error('Failed to create Shaka Player:', error);
        return null;
    }
}

// ---------------------------
// Load Stream with Shaka Player (DEBUG VERSION)
// ---------------------------
async function loadShakaStream(streamData) {
    destroyCurrent();
    showLoader(true);

    try {
        console.group('üîç Shaka Player - Loading Stream');
        
        if (!window.shaka) {
            throw new Error('Shaka Player library not loaded');
        }
        
        // Create video element
        const video = setupVideoElement();
        videoWrapper.appendChild(video);
        currentVideo = video;

        // Install polyfills
        shaka.polyfill.installAll();
        
        // Create player
        const player = new shaka.Player(video);
        currentShaka = player;
        
        // Error handling
        player.addEventListener('error', (event) => {
            console.error('Shaka Player error:', event.detail);
            showLoader(false);
        });

        // ‚úÖ CORRECT CONFIGURATION - No invalid keys
        player.configure({
            streaming: {
                bufferingGoal: 30,
                rebufferingGoal: 2,
                ignoreTextStreamFailures: true,
                lowLatencyMode: false
            },
            manifest: {
                dash: {
                    ignoreMinBufferTime: true,
                    autoCorrectDrift: true,
                    ignoreEmptyAdaptationSet: true
                }
            }
        });

  // DRM configuration with better error handling
// DRM configuration with better error handling
if (streamData.licenseServer) {
    console.log('üîí Configuring DRM...');
    console.log('License server:', streamData.licenseServer);
    
    const drmConfig = {
        servers: {
            'com.widevine.alpha': streamData.licenseServer
        },
        advanced: {
            'com.widevine.alpha': {
                videoRobustness: "SW_SECURE_CRYPTO",
                audioRobustness: "SW_SECURE_CRYPTO"
            }
        },
        // ‚úÖ Add retry configuration
        retryParameters: {
            maxAttempts: 3,
            baseDelay: 1000,
            backoffFactor: 2,
            fuzzFactor: 0.5,
            timeout: 30000
        }
    };
    
    player.configure({ drm: drmConfig });
    console.log('‚úÖ DRM configured');
}


// ‚úÖ Enhanced license request handling
player.getNetworkingEngine().registerRequestFilter((type, request) => {
    if (type === shaka.net.NetworkingEngine.RequestType.LICENSE) {
        console.log('üì® License request details:', {
            url: request.uris[0],
            method: request.method,
            headers: request.headers,
            body: request.body ? '***ENCRYPTED***' : 'No body'
        });
        
        // Add required headers
        request.headers = {
            'Content-Type': 'application/octet-stream',
            ...request.headers,
            ...streamData.licenseHeaders
        };
        
        // Log the request for debugging
        console.log('üìã Final license request headers:', request.headers);
    }
});

// ‚úÖ Add response filter to see license server response
player.getNetworkingEngine().registerResponseFilter((type, response) => {
    if (type === shaka.net.NetworkingEngine.RequestType.LICENSE) {
        console.log('üìÑ License response:', {
            status: response.status,
            statusText: response.statusText,
            headers: response.headers,
            data: response.data ? '***LICENSE DATA***' : 'No data'
        });
        
        if (response.status !== 200) {
            console.error('‚ùå License server returned error:', response.status, response.statusText);
        }
    }
});
        // License headers
        if (streamData.licenseHeaders) {
            player.getNetworkingEngine().registerRequestFilter((type, request) => {
                if (type === shaka.net.NetworkingEngine.RequestType.LICENSE) {
                    Object.assign(request.headers, streamData.licenseHeaders);
                }
            });
        }

        console.log('Loading stream:', streamData.link);
        // In your loadShakaStream function, after player.load():
        await player.load(streamData.link);
        console.log('‚úÖ Stream loaded successfully!');

        // ‚úÖ Add this line to setup custom time display for live streams
        setupCustomTimeDisplay(video, player);

        showLoader(false);
        
        // Try to play
        const playPromise = video.play();
        if (playPromise !== undefined) {
            playPromise.catch(err => {
                console.log('Autoplay prevented:', err);
                unmuteBtn.style.display = 'block';
            });
        }
        
        console.groupEnd();

    } catch (error) {
        console.error('Stream loading failed:', error);
        showLoader(false);
        channelName.textContent = `${channelName.textContent} - Error: ${error.message}`;
        
        // Fallback to regular DASH
        if (streamData.link.includes('.mpd')) {
            loadDash(streamData.link, streamData.license);
        }
    }
}


// ---------------------------
// Enhanced initialize with user interaction handling
// ---------------------------
async function initializeChannels() {
    try {
        if (!Array.isArray(channels)) {
            throw new Error('Channels data is not a valid array');
        }
        
        console.log(`üì∫ Found ${channels.length} channels`);
        
        buildChannelList(channels);
        
        if (channels.length > 0) {
            const firstChannel = channels[0];
            channelName.textContent = firstChannel.name;
            
            // ‚úÖ WAIT FOR PAGE TO BE FULLY READY
            await new Promise(resolve => setTimeout(resolve, 800));
            
            console.log('üé¨ Auto-playing first channel:', firstChannel.name);
            loadChannel(firstChannel);
            
        } else {
            channelName.innerText = "No channels available";
        }
        
    } catch (err) {
        console.error("Failed to initialize channels:", err);
        channelName.innerText = "Failed to load channels";
    }
}


// ---------------------------
// Smart Loader with Network Detection
// ---------------------------
async function loadChannelOptimized(channel) {
    if (!channel || !channel.type) return;
    
    channelName.textContent = channel.name;
    showLoader(true);

    try {
        // Detect network speed (optional)
        const networkSpeed = await detectNetworkSpeed();
        const networkProfile = getOptimizedConfigForSpeed(networkSpeed);
        
        console.log(`üìä Using network profile: ${networkSpeed.toFixed(1)}Mbps`);

        if (channel.type === "youtube") {
            loadYouTube(channel.link);
        } else if (channel.type === "m3u8") {
            loadHlsOptimized(channel.link);
        } else if (channel.type === "mpd") {
            if (channel.clearkey || channel.licenseServer) {
                loadStreamOptimizedForSlowNetwork(channel);
            } else {
                loadDashOptimized(channel.link);
            }
        }
    } catch (error) {
        console.error('Error loading channel:', error);
        channelName.textContent = `${channel.name} - Error: ${error.message}`;
        showLoader(false);
    }
}


  // ---------------------------
// Enhanced DRM Support Check
// ---------------------------
async function checkDRMSupport() {
    console.log('DRM Support Check:');
    console.log('MediaSource:', window.MediaSource ? 'Supported' : 'Not Supported');
    console.log('EME (Encrypted Media Extensions):', navigator.requestMediaKeySystemAccess ? 'Supported' : 'Not Supported');
    
    if (navigator.requestMediaKeySystemAccess) {
        // Check ClearKey support WITH robustness levels
        navigator.requestMediaKeySystemAccess('org.w3.clearkey', [{
            initDataTypes: ['keyids', 'cenc'],
            audioCapabilities: [{ 
                contentType: 'audio/mp4; codecs="mp4a.40.2"',
                robustness: 'SW_SECURE_CRYPTO' // Add robustness
            }],
            videoCapabilities: [{ 
                contentType: 'video/mp4; codecs="avc1.42E01E"',
                robustness: 'SW_SECURE_CRYPTO' // Add robustness
            }]
        }]).then(() => {
            console.log('ClearKey DRM: Supported');
        }).catch((e) => {
            console.log('ClearKey DRM: Not Supported', e.message);
        });

        // Check Widevine support WITH robustness levels
        navigator.requestMediaKeySystemAccess('com.widevine.alpha', [{
            initDataTypes: ['cenc'],
            audioCapabilities: [{ 
                contentType: 'audio/mp4; codecs="mp4a.40.2"',
                robustness: 'SW_SECURE_CRYPTO' // Add robustness
            }],
            videoCapabilities: [{ 
                contentType: 'video/mp4; codecs="avc1.42E01E"',
                robustness: 'SW_SECURE_CRYPTO' // Add robustness
            }]
        }]).then(() => {
            console.log('Widevine DRM: Supported');
        }).catch((e) => {
            console.log('Widevine DRM: Not Supported', e.message);
        });

        // Also check for hardware security if needed
        navigator.requestMediaKeySystemAccess('com.widevine.alpha', [{
            initDataTypes: ['cenc'],
            audioCapabilities: [{ 
                contentType: 'audio/mp4; codecs="mp4a.40.2"',
                robustness: 'HW_SECURE_CRYPTO' // Hardware-level security
            }],
            videoCapabilities: [{ 
                contentType: 'video/mp4; codecs="avc1.42E01E"',
                robustness: 'HW_SECURE_CRYPTO' // Hardware-level security
            }]
        }]).then(() => {
            console.log('Widevine HW_SECURE_CRYPTO: Supported');
        }).catch(() => {
            console.log('Widevine HW_SECURE_CRYPTO: Not Supported');
        });
    }
}

//ClearKey Support Check
function checkClearKeySupport() {
    console.group('üîë ClearKey DRM Support Check');
    
    if (!navigator.requestMediaKeySystemAccess) {
        console.error('‚ùå EME not supported in this browser');
        console.groupEnd();
        return false;
    }
    
    const clearkeyConfig = [{
        initDataTypes: ['cenc', 'keyids'],
        audioCapabilities: [{
            contentType: 'audio/mp4; codecs="mp4a.40.2"'
        }],
        videoCapabilities: [{
            contentType: 'video/mp4; codecs="avc1.42E01E"'
        }],
        // ClearKey specific configuration
        distinctiveIdentifier: 'not-allowed',
        persistentState: 'not-allowed',
        sessionTypes: ['temporary']
    }];
    
    navigator.requestMediaKeySystemAccess('org.w3.clearkey', clearkeyConfig)
        .then((access) => {
            console.log('‚úÖ ClearKey DRM supported');
            console.log('Key system:', access.keySystem);
            return access.createMediaKeys();
        })
        .then((mediaKeys) => {
            console.log('‚úÖ MediaKeys created successfully');
            console.log('ClearKey ready to use');
        })
        .catch((error) => {
            console.error('‚ùå ClearKey not supported:', error);
        });
    
    console.groupEnd();
}
// Run this in console: checkClearKeySupport()


async function loadStreamWithSmartDRM(streamData) {
    destroyCurrent();
    showLoader(true);

    try {
        const video = setupVideoElement();
        videoWrapper.appendChild(video);
        currentVideo = video;

        shaka.polyfill.installAll();
        const player = new shaka.Player();
        await player.attach(video);
        currentShaka = player;

        // Get DRM support (use cached or detect)
        const drmSupport = window.drmSupport || await detectDRMSupport();
        
        console.log('üéØ Smart DRM Loading with support:', drmSupport);
        
        // Configure DRM based on available support and stream requirements
        const drmConfig = await buildDRMConfig(streamData, drmSupport);
        
        if (Object.keys(drmConfig.servers).length > 0 || Object.keys(drmConfig.clearKeys || {}).length > 0) {
            player.configure({ drm: drmConfig });
            console.log('üîí DRM configured:', drmConfig);
        } else {
            console.log('‚ÑπÔ∏è No DRM configuration applied - playing without DRM');
        }

        player.configure({
        drm: {
        clearKeys: {
        'f703e4c8ec9041eeb5028ab4248fa094': 'c22f2162e176eee6273a5d0b68d19530',
        'f703e4c8ec9041eeb5028ab4248fa094': 'c22f2162e176eee6273a5d0b68d19530',
        '4bbdc78024a54662854b412d01fafa16': '6039ec9b213aca913821677a28bd78ae',
        '92032b0e41a543fb9830751273b8debd': '03f8b65e2af785b10d6634735dbe6c11',
        'c24a7811d9ab46b48b746a0e7e269210': 'c321afe1689b07d5b7e55bd025c483ce'
        }
        }
    });



        // Basic player configuration
        player.configure({
            streaming: {
                bufferingGoal: 15,
                rebufferingGoal: 1.5,
                bufferBehind: 20,
                lowLatencyMode: false
            }
        });

        // Load the stream
        await player.load(streamData.link);
        console.log('‚úÖ Stream loaded successfully');
        
        showLoader(false);
        
        video.play().catch(err => {
            console.log('Autoplay prevented:', err);
            unmuteBtn.style.display = 'block';
        });

        // Auto-play with better error handling
        try {
            await video.play();
            console.log('‚ñ∂Ô∏è Playback started successfully');
        } catch (err) {
            console.log('Autoplay prevented:', err);
            if (unmuteBtn) unmuteBtn.style.display = 'block';
            // Show play button overlay for user interaction
            showPlayButtonOverlay();
        }

    } catch (error) {
        console.error('üí• Smart DRM load failed:', error);
        handleDRMFallback(streamData, error);
    }
}

async function loadStream(streamData) {
    // DRM configuration from service
    const drmConfig = {
        servers: {
            'com.widevine.alpha': streamData.drm.license_server_url
        },
        advanced: {
            'com.widevine.alpha': {
                videoRobustness: "SW_SECURE_CRYPTO",
                audioRobustness: "SW_SECURE_CRYPTO"
            }
        }
    };

    // Configure player
    player.configure({
        streaming: {
            abr: {
                enabled: streamData.adaptive_bitrate || false
            }
        },
        drm: drmConfig
    });

    // Add license request headers if required
    player.getNetworkingEngine().registerRequestFilter((type, request) => {
        if (type === shaka.net.NetworkingEngine.RequestType.LICENSE) {
            request.headers = {
                ...request.headers,
                ...streamData.drm.headers
            };
        }
    });

    try {
        await player.load(streamData.manifest_url);
    } catch (error) {
        console.error('Stream loading failed:', error);
    }
}
    // Unmute button functionality
    unmuteBtn.addEventListener('click', function() {
        if (currentVideo) {
            currentVideo.muted = false;
            unmuteBtn.style.display = 'none';
            currentVideo.play().catch(err => {
                console.log('Play after unmute failed:', err);
            });
        }
    });


    // ---------------------------
// Fixed DRM Support Detection (No Warnings)
// ---------------------------
async function detectDRMSupport() {
    return new Promise((resolve) => {
        const support = {
            widevine: false,
            clearkey: false,
            playready: false
        };
        
        // ‚úÖ FIXED: Add robustness levels to avoid warnings
        const widevineConfig = [{
            initDataTypes: ['cenc'],
            audioCapabilities: [{ 
                contentType: 'audio/mp4; codecs="mp4a.40.2"',
                robustness: 'SW_SECURE_CRYPTO' // ‚úÖ Added robustness
            }],
            videoCapabilities: [{ 
                contentType: 'video/mp4; codecs="avc1.42E01E"',
                robustness: 'SW_SECURE_CRYPTO' // ‚úÖ Added robustness
            }],
            distinctiveIdentifier: 'optional',
            persistentState: 'optional',
            sessionTypes: ['temporary']
        }];
        
        const clearkeyConfig = [{
            initDataTypes: ['cenc'],
            audioCapabilities: [{ 
                contentType: 'audio/mp4; codecs="mp4a.40.2"',
                robustness: '' // ‚úÖ Empty string for ClearKey (no robustness requirement)
            }],
            videoCapabilities: [{ 
                contentType: 'video/mp4; codecs="avc1.42E01E"',
                robustness: '' // ‚úÖ Empty string for ClearKey
            }],
            distinctiveIdentifier: 'not-allowed',
            persistentState: 'not-allowed',
            sessionTypes: ['temporary']
        }];

        // Test Widevine
        navigator.requestMediaKeySystemAccess('com.widevine.alpha', widevineConfig)
            .then(() => { 
                support.widevine = true; 
                console.log('‚úÖ Widevine supported');
            })
            .catch(() => { 
                support.widevine = false; 
                console.log('‚ùå Widevine not supported');
            })
            .finally(() => {
                // Test ClearKey
                navigator.requestMediaKeySystemAccess('org.w3.clearkey', clearkeyConfig)
                    .then(() => { 
                        support.clearkey = true; 
                        console.log('‚úÖ ClearKey supported');
                    })
                    .catch(() => { 
                        support.clearkey = false; 
                        console.log('‚ùå ClearKey not supported');
                    })
                    .finally(() => {
                        resolve(support);
                    });
            });
    });
}

async function buildDRMConfig(streamData, drmSupport) {
    const drmConfig = {
        servers: {},
        advanced: {},
        clearKeys: {}
    };

    // Priority 1: Use specified DRM type if supported
    if (streamData.drmType === 'widevine' && streamData.licenseServer && drmSupport.widevine) {
        drmConfig.servers['com.widevine.alpha'] = streamData.licenseServer;
        drmConfig.advanced['com.widevine.alpha'] = {
            videoRobustness: "SW_SECURE_CRYPTO", // ‚úÖ Added robustness
            audioRobustness: "SW_SECURE_CRYPTO"  // ‚úÖ Added robustness
        };
    }
    else if (streamData.drmType === 'clearkey' && streamData.clearkey && drmSupport.clearkey) {
        drmConfig.servers['org.w3.clearkey'] = 'data:application/json;base64,eyJrZXlzIjpbXSwidHlwZSI6InRlbXBvcmFyeSJ9';
        drmConfig.clearKeys = parseClearKeyData(streamData.clearkey);
        // ClearKey doesn't need robustness levels
    }
    // Priority 2: Auto-detect based on available data and support
    else if (streamData.licenseServer && drmSupport.widevine) {
        drmConfig.servers['com.widevine.alpha'] = streamData.licenseServer;
        drmConfig.advanced['com.widevine.alpha'] = {
            videoRobustness: "SW_SECURE_CRYPTO", // ‚úÖ Added robustness
            audioRobustness: "SW_SECURE_CRYPTO"  // ‚úÖ Added robustness
        };
    }
    else if (streamData.clearkey && drmSupport.clearkey) {
        drmConfig.servers['org.w3.clearkey'] = 'data:application/json;base64,eyJrZXlzIjpbXSwidHlwZSI6InRlbXBvcmFyeSJ9';
        drmConfig.clearKeys = parseClearKeyData(streamData.clearkey);
    }

    return drmConfig;
}


// ---------------------------
// Network Speed Detection
// ---------------------------
async function detectNetworkSpeed() {
    console.group('üìä Network Speed Test');
    
    const testFile = 'https://httpbin.org/stream-bytes/1000000'; // 1MB test file
    const startTime = Date.now();
    
    try {
        const response = await fetch(testFile);
        const blob = await response.blob();
        const endTime = Date.now();
        
        const fileSizeMB = blob.size / (1024 * 1024);
        const durationSeconds = (endTime - startTime) / 1000;
        const speedMbps = (fileSizeMB * 8) / durationSeconds;
        
        console.log(`üì° Network Speed: ${speedMbps.toFixed(2)} Mbps`);
        console.log(`‚è±Ô∏è  Download Time: ${durationSeconds.toFixed(2)} seconds`);
        console.log(`üì¶ File Size: ${fileSizeMB.toFixed(2)} MB`);
        
        return speedMbps;
    } catch (error) {
        console.error('Network test failed:', error);
        return 3; // Default to 3Mbps assumption
    } finally {
        console.groupEnd();
    }
}

function getOptimizedConfigForSpeed(speedMbps) {
    const configs = {
        // For very slow connections (< 2Mbps)
        slow: {
            bufferingGoal: 10,
            rebufferingGoal: 1,
            bufferBehind: 15,
            maxBandwidth: 1500000, // 1.5Mbps
            maxWidth: 640,
            maxHeight: 360
        },
        // For moderate connections (2-5Mbps)
        moderate: {
            bufferingGoal: 15,
            rebufferingGoal: 1.5,
            bufferBehind: 20,
            maxBandwidth: 2500000, // 2.5Mbps
            maxWidth: 854,
            maxHeight: 480
        },
        // For good connections (> 5Mbps)
        fast: {
            bufferingGoal: 30,
            rebufferingGoal: 2,
            bufferBehind: 30,
            maxBandwidth: 8000000, // 8Mbps
            maxWidth: 1920,
            maxHeight: 1080
        }
    };
    
    if (speedMbps < 2) return configs.slow;
    if (speedMbps <= 5) return configs.moderate;
    return configs.fast;
}

function loadShakaStreamWithClearKey(streamData) {
    destroyCurrent();
    showLoader(true);

    try {
        const video = setupVideoElement();
        videoWrapper.appendChild(video);
        currentVideo = video;

        shaka.polyfill.installAll();
        
        // Create player with new method
        const player = new shaka.Player();
         player.attach(video);
        currentShaka = player;

        // ClearKey DRM configuration
        if (streamData.clearkey) {
            console.log('üîë Configuring ClearKey DRM...');
            
            const clearkeyConfig = {
                servers: {
                    'org.w3.clearkey': 'data:application/json;base64,eyJrZXlzIjpbXSwidHlwZSI6InRlbXBvcmFyeSJ9' // Empty keyset
                },
                advanced: {
                    'org.w3.clearkey': {
                        // Optional: Add any ClearKey-specific configuration
                    }
                },
                clearKeys: {} // Will be populated with keys
            };

            // Parse ClearKey data (format: "keyId:keyValue" or array of keys)
            if (typeof streamData.clearkey === 'string') {
                // Single key: "keyId:keyValue"
                const [keyId, keyValue] = streamData.clearkey.split(':');
                if (keyId && keyValue) {
                    clearkeyConfig.clearKeys[keyId] = keyValue;
                }
            } else if (Array.isArray(streamData.clearkey)) {
                // Multiple keys: [{keyId: '...', key: '...'}, ...]
                streamData.clearkey.forEach(keyData => {
                    if (keyData.keyId && keyData.key) {
                        clearkeyConfig.clearKeys[keyData.keyId] = keyData.key;
                    }
                });
            } else if (typeof streamData.clearkey === 'object') {
                // Object format: {keyId1: 'key1', keyId2: 'key2'}
                clearkeyConfig.clearKeys = { ...streamData.clearkey };
            }

            console.log('ClearKey keys configured:', Object.keys(clearkeyConfig.clearKeys).length);
            player.configure({ drm: clearkeyConfig });
        }

        // Basic configuration
        player.configure({
            streaming: {
                bufferingGoal: 30,
                rebufferingGoal: 2
            }
        });

        player.configure({
        drm: {
        clearKeys: {
        'f703e4c8ec9041eeb5028ab4248fa094': 'c22f2162e176eee6273a5d0b68d19530',
        'f703e4c8ec9041eeb5028ab4248fa094': 'c22f2162e176eee6273a5d0b68d19530',
        '4bbdc78024a54662854b412d01fafa16': '6039ec9b213aca913821677a28bd78ae',
        '92032b0e41a543fb9830751273b8debd': '03f8b65e2af785b10d6634735dbe6c11',
        'c24a7811d9ab46b48b746a0e7e269210': 'c321afe1689b07d5b7e55bd025c483ce'
        }
        }
    });

        // Load the stream
         player.load(streamData.link);
        console.log('‚úÖ Stream loaded with ClearKey DRM');
        
        showLoader(false);
        video.play().catch(err => {
            console.log('Autoplay prevented:', err);
            unmuteBtn.style.display = 'block';
        });

    } catch (error) {
        console.error('ClearKey DRM failed:', error);
        showLoader(false);
        channelName.textContent = `${channelName.textContent} - DRM Error`;
    }
}
//Updated Custom Time Display (Simplified)
// ---------------------------
// Enhanced Live Stream Time Display
// ---------------------------
// ---------------------------
// Fixed Live Stream Time Display (Public APIs Only)
// ---------------------------
function setupCustomTimeDisplay(video, player) {
    // Remove existing display
    const existingDisplay = document.getElementById('custom-time-display');
    if (existingDisplay) existingDisplay.remove();
    
    // Remove any existing live controls
    const existingControls = document.getElementById('live-stream-controls');
    if (existingControls) existingControls.remove();
    
    // Create custom time display
    const timeDisplay = document.createElement('div');
    timeDisplay.id = 'custom-time-display';
    timeDisplay.style.cssText = `
        position: absolute;
        bottom: 60px;
        right: 15px;
        background: rgba(255, 50, 50, 0.9);
        color: white;
        padding: 8px 12px;
        border-radius: 16px;
        font-size: 14px;
        font-weight: bold;
        z-index: 1000;
        font-family: Arial, sans-serif;
        pointer-events: none;
        box-shadow: 0 2px 10px rgba(0,0,0,0.5);
    `;
    
    // Create live controls
    const controlsHTML = `
        <div id="live-stream-controls" style="
            position: absolute; 
            bottom: 0; 
            left: 0; 
            right: 0; 
            background: linear-gradient(transparent, rgba(0,0,0,0.8)); 
            padding: 15px 20px; 
            display: flex; 
            align-items: center; 
            gap: 15px;
            z-index: 999;
            pointer-events: auto;
        ">
            <button id="live-play-pause" style="
                background: rgba(255,255,255,0.2); 
                border: none; 
                color: white; 
                width: 40px; 
                height: 40px; 
                border-radius: 50%; 
                font-size: 16px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                backdrop-filter: blur(10px);
            ">‚è∏Ô∏è</button>
            
            <div style="color: #ccc; font-size: 12px; margin-left: 10px;">LIVE STREAM</div>
            
            <button id="live-fullscreen" style="
                background: rgba(255,255,255,0.2); 
                border: none; 
                color: white; 
                width: 40px; 
                height: 40px; 
                border-radius: 50%; 
                font-size: 16px;
                cursor: pointer;
                margin-left: auto;
                display: flex;
                align-items: center;
                justify-content: center;
                backdrop-filter: blur(10px);
            ">‚õ∂</button>
        </div>
    `;
    
    const controlsElement = document.createElement('div');
    controlsElement.innerHTML = controlsHTML;
    videoWrapper.appendChild(controlsElement);
    videoWrapper.appendChild(timeDisplay);
    
    let isLive = false;
    let lastUpdateTime = 0;
    
    // ‚úÖ FIXED: Use only public APIs
    const updateTimeDisplay = () => {
        if (!player || !video) return;
        
        try {
            const currentTime = video.currentTime;
            const duration = video.duration;
            
            // ‚úÖ FIXED: Use public isLive() method instead of internal manifest
            isLive = player.isLive();
            
            if (isLive) {
                // For live streams, we can't access the timeline directly
                // but we can detect live streams and show appropriate display
                
                // Calculate time since last update to detect if we're near live edge
                const now = Date.now();
                const timeSinceLastUpdate = now - lastUpdateTime;
                
                if (timeSinceLastUpdate > 2000) {
                    // If video time hasn't updated in 2+ seconds, we might be behind
                    timeDisplay.textContent = `LIVE -${Math.round(timeSinceLastUpdate / 1000)}s`;
                    timeDisplay.style.background = 'rgba(255, 165, 0, 0.9)';
                } else {
                    // Close to real-time
                    timeDisplay.textContent = '‚óè LIVE';
                    timeDisplay.style.background = 'rgba(255, 50, 50, 0.9)';
                }
                
                lastUpdateTime = now;
            } else {
                // VOD stream - show normal time
                timeDisplay.textContent = formatTimeDisplay(currentTime, duration);
                timeDisplay.style.background = 'rgba(0, 0, 0, 0.7)';
            }
            
        } catch (error) {
            // Fallback detection for live streams
            if (video.duration > 86400 || video.duration === Infinity) {
                timeDisplay.textContent = '‚óè LIVE';
                timeDisplay.style.background = 'rgba(255, 50, 50, 0.9)';
            } else {
                timeDisplay.textContent = formatTimeDisplay(video.currentTime, video.duration);
            }
        }
    };
    
    // Update frequently for live streams
    const timeUpdateInterval = setInterval(updateTimeDisplay, 1000);
    
    // Also update on video time updates
    video.addEventListener('timeupdate', updateTimeDisplay);
    
    // Setup control handlers
    document.getElementById('live-play-pause').addEventListener('click', (e) => {
        e.stopPropagation();
        if (video.paused) {
            video.play();
            e.target.textContent = '‚è∏Ô∏è';
        } else {
            video.pause();
            e.target.textContent = '‚ñ∂Ô∏è';
        }
    });
    
    document.getElementById('live-fullscreen').addEventListener('click', (e) => {
        e.stopPropagation();
        if (document.fullscreenElement) {
            document.exitFullscreen();
        } else {
            videoWrapper.requestFullscreen();
        }
    });
    
    // Update play/pause button based on video state
    video.addEventListener('play', () => {
        const btn = document.getElementById('live-play-pause');
        if (btn) btn.textContent = '‚è∏Ô∏è';
    });
    
    video.addEventListener('pause', () => {
        const btn = document.getElementById('live-play-pause');
        if (btn) btn.textContent = '‚ñ∂Ô∏è';
    });
    
    // Cleanup function
    const cleanup = () => {
        clearInterval(timeUpdateInterval);
        video.removeEventListener('timeupdate', updateTimeDisplay);
        if (timeDisplay.parentNode) timeDisplay.remove();
        if (controlsElement.parentNode) controlsElement.remove();
    };
    
    video.addEventListener('emptied', cleanup);
    video.addEventListener('error', cleanup);
    
    // Initial update
    updateTimeDisplay();
    lastUpdateTime = Date.now();
    
    return cleanup;
}

function setupSimpleLiveDisplay(video) {
    const liveIndicator = document.createElement('div');
    liveIndicator.id = 'simple-live-indicator';
    liveIndicator.style.cssText = `
        position: absolute;
        bottom: 20px;
        right: 20px;
        background: #ff0000;
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 14px;
        font-weight: bold;
        z-index: 1000;
        pointer-events: none;
    `;
    liveIndicator.textContent = '‚óè LIVE';
    
    videoWrapper.appendChild(liveIndicator);
    
    // Hide native controls time display
    video.controls = false;
    
    return () => {
        if (liveIndicator.parentNode) liveIndicator.remove();
        video.controls = true;
    };
}

// ---------------------------
// Debug channels data
// ---------------------------
function debugChannelsData() {
    console.group('üîç Channels Data Debug');
    console.log('Channels array:', channels);
    console.log('Channels length:', channels.length);
    
    if (Array.isArray(channels)) {
        channels.forEach((channel, index) => {
            console.log(`Channel ${index}:`, {
                name: channel.name,
                type: channel.type,
                link: channel.link,
                logo: channel.logo,
                hasLogo: !!(channel.logo && channel.logo !== 'undefined')
            });
        });
    }
    
    console.groupEnd();
}

// Call this in your console to check your data
// debugChannelsData();

    // ---------------------------
    // Initialize channels
    // ---------------------------
    // ---------------------------
// Initialize channels (UPDATED)
// ---------------------------
function initializeChannels() {
    try {
        if (!Array.isArray(channels)) {
            throw new Error('Channels data is not a valid array');
        }
        
        // Validate and clean channels data
        const validatedChannels = validateChannels(channels);
        
        if (validatedChannels.length === 0) {
            throw new Error('No valid channels found');
        }
        
        buildChannelList(channels);
        
        if (channels.length > 0) {
            // ‚úÖ Auto-play the first channel
            const firstChannel = channels[0];
            console.log('üé¨ Auto-playing first channel:', firstChannel.name);
            loadChannel(firstChannel);
        } else {
            channelName.innerText = "No channels available";
        }
        
    } catch (err) {
        console.error("Failed to initialize channels:", err);
        channelName.innerText = "Failed to load channels";
        
        channelList.innerHTML = `<div style="color: #ff6b6b; text-align: center; padding: 20px;">
            Error loading channels: ${err.message}
        </div>`;
    }
}


// ---------------------------
// Safe logo loader
// ---------------------------
function createChannelLogo(channel) {
    const img = document.createElement('img');
    
    // Set alt text
    img.alt = channel.name || 'Channel Logo';
    
    // Handle logo URL safely
    if (channel.logo && channel.logo !== 'undefined' && channel.logo.startsWith('http')) {
        img.src = channel.logo;
    } else {
        // Use placeholder
        img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzMzMyIvPjx0ZXh0IHg9IjUwIiB5PSI1MCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE0IiBmaWxsPSIjZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iMC4zNWVtIj5OTyBMT0dPPC90ZXh0Pjwvc3ZnPg==';
    }
    
    // Error handling for broken images
    img.onerror = function() {
        this.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzMzMyIvPjx0ZXh0IHg9IjUwIiB5PSI1MCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE0IiBmaWxsPSIjZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iMC4zNWVtIj5OTyBMT0dPPC90ZXh0Pjwvc3ZnPg==';
        this.alt = 'Logo not available';
    };
    
    // Lazy loading for performance
    img.loading = 'lazy';
    
    return img;
}
    // ---------------------------
// Build channel list with auto-selection
// ---------------------------
function buildChannelList(channels) {
    channelList.innerHTML = "";
    channels.forEach((channel, index) => {
        const div = document.createElement("div");
        div.className = "channel";
        div.title = channel.name || 'Unnamed Channel';
        
        const logoUrl = channel.logo && channel.logo !== 'undefined' ? channel.logo : '';
        const placeholderSvg = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzMzMyIvPjx0ZXh0IHg9IjUwIiB5PSI1MCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE0IiBmaWxsPSIjZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iMC4zNWVtIj5OTyBMT0dPPC90ZXh0Pjwvc3ZnPg==';
        
        div.innerHTML = `<img src="${logoUrl || placeholderSvg}" alt="${channel.name || 'Channel'}" onerror="this.src='${placeholderSvg}'">`;
        
        div.addEventListener("click", () => {
            document.querySelectorAll(".channel").forEach(el => el.classList.remove("active"));
            div.classList.add("active");
            loadChannel(channel);
        });
        
        channelList.appendChild(div);
        
        // ‚úÖ Force first channel to be active
        if (index === 0) {
            div.classList.add("active");
        }
    });
}

// ---------------------------
// Validate and clean channels data
// ---------------------------
function validateChannels(channels) {
    if (!Array.isArray(channels)) {
        console.error('Channels data is not an array');
        return [];
    }
    
    return channels.map((channel, index) => {
        // Ensure channel has required properties
        const validatedChannel = {
            name: channel.name || `Channel ${index + 1}`,
            type: channel.type || 'm3u8', // default type
            link: channel.link || '',
            logo: channel.logo || '', // empty string instead of undefined
            // Preserve other properties
            ...channel
        };
        
        // Clean up logo URL
        if (validatedChannel.logo === 'undefined' || validatedChannel.logo === undefined) {
            validatedChannel.logo = '';
        }
        
        // Log warnings for invalid channels
        if (!validatedChannel.link) {
            console.warn(`Channel "${validatedChannel.name}" has no stream link`);
        }
        
        return validatedChannel;
    });
}

    // ---------------------------
    // Helper Functions
    // ---------------------------
    function showLoader(show) { 
        loader.style.display = show ? 'block' : 'none'; 
    }

    function log(...args) { 
        console.log('[IPTV]', ...args); 
    }

    function setupVideoElement() {
    const v = document.createElement("video");
    v.setAttribute("playsinline", "true");
    v.controls = true;
    v.autoplay = true;
    v.muted = true;
    v.preload = "auto";
    v.style.width = "100%";
    v.style.height = "100%";
    v.className = "shaka-video"; // Add class for easier targeting
    
    // Enhanced error event listener - COMPLETE VERSION
v.addEventListener('error', (e) => {
    console.group('üé¨ VIDEO ELEMENT ERROR - ENHANCED DEBUGGING');
    
    // 1. Basic event info
    console.error('=== EVENT OBJECT ===');
    console.error('Event type:', e.type);
    console.error('Event target:', e.target);
    console.error('Event currentTarget:', e.currentTarget);
    console.error('Is trusted:', e.isTrusted);
    
    // 2. Video element state - MULTIPLE WAYS TO GET ERROR
    console.error('=== VIDEO ELEMENT STATE ===');
    console.error('Video element:', v);
    console.error('Video error property (v.error):', v.error);
    console.error('Video readyState:', v.readyState, getReadyStateText(v.readyState));
    console.error('Video networkState:', v.networkState, getNetworkStateText(v.networkState));
    console.error('Video src:', v.src);
    console.error('Video currentSrc:', v.currentSrc);
    console.error('Video duration:', v.duration);
    console.error('Video videoWidth:', v.videoWidth);
    console.error('Video videoHeight:', v.videoHeight);
    
    // 3. Try alternative ways to get error info
    console.error('=== ALTERNATIVE ERROR DETECTION ===');
    
    // Method 1: Check if error is on the event
    console.error('Event error property:', e.error);
    
    // Method 2: Check MediaError constants
    if (window.MediaError) {
        console.error('MediaError constants available');
        console.error('MEDIA_ERR_ABORTED:', MediaError.MEDIA_ERR_ABORTED);
        console.error('MEDIA_ERR_NETWORK:', MediaError.MEDIA_ERR_NETWORK);
        console.error('MEDIA_ERR_DECODE:', MediaError.MEDIA_ERR_DECODE);
        console.error('MEDIA_ERR_SRC_NOT_SUPPORTED:', MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED);
    }
    
    // Method 3: Try to create a MediaError to test
    try {
        const testError = new MediaError();
        console.error('MediaError constructor available');
    } catch (err) {
        console.error('MediaError constructor not available:', err);
    }
    
    // 4. Check browser-specific error properties
    console.error('=== BROWSER SPECIFIC ===');
    console.error('Video mozHasAudio:', v.mozHasAudio);
    console.error('Video webkitAudioDecodedByteCount:', v.webkitAudioDecodedByteCount);
    console.error('Video webkitVideoDecodedByteCount:', v.webkitVideoDecodedByteCount);
    
    // 5. Check if it's a Shaka-specific issue
    if (window.currentShaka) {
        console.error('=== SHAKA PLAYER STATE ===');
        try {
            const player = currentShaka;
            console.error('Shaka player exists');
            console.error('Shaka isLive:', player.isLive());
            console.error('Shaka isBuffering:', player.isBuffering());
            
            const manifest = player.getManifest();
            console.error('Shaka manifest loaded:', !!manifest);
            
            if (manifest) {
                console.error('Shaka variants:', manifest.variants.length);
            }
        } catch (shakaErr) {
            console.error('Shaka check error:', shakaErr);
        }
    }
    
    // 6. Network and performance info
    console.error('=== PERFORMANCE INFO ===');
    if (performance && performance.getEntriesByType) {
        const resources = performance.getEntriesByType('resource');
        const videoResources = resources.filter(r => r.name.includes('.mpd') || r.name.includes('.m3u8'));
        console.error('Video-related resources:', videoResources);
    }
    
    console.groupEnd();
    
    // Show user message based on available info
    showLoader(false);
    determineErrorMessage(v);
});

function determineErrorMessage(video) {
    let errorMessage = 'Video playback failed';
    
    // Try to determine error from available info
    if (video.networkState === video.NETWORK_NO_SOURCE) {
        errorMessage = 'No video source found';
    } else if (video.readyState === video.HAVE_NOTHING) {
        errorMessage = 'Video failed to load';
    } else if (video.error) {
        // If we eventually get an error object
        const codes = {
            1: 'Video loading aborted',
            2: 'Network error',
            3: 'Video decoding error', 
            4: 'Video format not supported'
        };
        errorMessage = codes[video.error.code] || 'Video error';
    }
    
    channelName.textContent = `${channelName.textContent} - ${errorMessage}`;
    console.error('User message:', errorMessage);
}

// Helper functions
function getReadyStateText(state) {
    const states = ['HAVE_NOTHING', 'HAVE_METADATA', 'HAVE_CURRENT_DATA', 'HAVE_FUTURE_DATA', 'HAVE_ENOUGH_DATA'];
    return states[state] || 'UNKNOWN';
}

function getNetworkStateText(state) {
    const states = ['NETWORK_EMPTY', 'NETWORK_IDLE', 'NETWORK_LOADING', 'NETWORK_NO_SOURCE'];
    return states[state] || 'UNKNOWN';
}
    }

// Add these to your setupVideoElement function
function setupVideoElement() {
    const v = document.createElement("video");
    // ... your existing setup code ...
    
    // ERROR DETECTION AT DIFFERENT STAGES
    
    // 1. Load start
    v.addEventListener('loadstart', () => {
        console.log('üöÄ Video load started - currentSrc:', v.currentSrc);
    });
    
    // 2. Progress (loading)
    // In your setupVideoElement function, update the progress event:
v.addEventListener('progress', () => {
    if (v.buffered.length > 0) {
        const bufferedEnd = v.buffered.end(0);
        
        // For live streams, show relative buffer instead of absolute time
        if (v.duration > 86400) { // Live stream
            const currentTime = v.currentTime;
            const bufferAhead = bufferedEnd - currentTime;
            console.log('üì• Live stream - buffer ahead:', bufferAhead.toFixed(1) + 's');
        } else {
            console.log('üì• Video loading progress - buffered:', bufferedEnd);
        }
    }
});
    
    // 3. Can play
    v.addEventListener('canplay', () => {
        console.log('‚úÖ Video can play - readyState:', v.readyState);
    });
    
    // 4. Stalled (buffering)
    v.addEventListener('stalled', () => {
        console.log('üîÑ Video stalled - networkState:', v.networkState);
    });
    
    // 5. Suspend (loading paused)
    v.addEventListener('suspend', () => {
        console.log('‚è∏Ô∏è Video loading suspended');
    });
    
    // 6. Abort
    v.addEventListener('abort', () => {
        console.log('‚ùå Video loading aborted');
    });
    
    // 7. Emptied (media removed)
    v.addEventListener('emptied', () => {
        console.log('üóëÔ∏è Video media emptied');
    });
    
    return v;
}


function checkShakaPlayerStatus() {
    console.group('üîç Shaka Player Status Check');
    
    if (!window.shaka) {
        console.error('‚ùå Shaka Player library not loaded');
        console.groupEnd();
        return false;
    }
    
    console.log('‚úÖ Shaka Player version:', shaka.Player.version);
    console.log('‚úÖ Browser supported:', shaka.Player.isBrowserSupported());
    
    if (currentShaka) {
        console.log('‚úÖ Shaka Player instance exists');
        try {
            const manifest = currentShaka.getManifest();
            console.log('‚úÖ Manifest loaded:', !!manifest);
            if (manifest) {
                console.log('Variants:', manifest.variants.length);
                console.log('Text streams:', manifest.textStreams.length);
                console.log('Is live:', manifest.presentationTimeline.isLive());
            }
        } catch (error) {
            console.error('‚ùå Error checking manifest:', error);
        }
    } else {
        console.log('‚ùå No Shaka Player instance');
    }
    
    console.groupEnd();
    return true;
}
// Run this in console: checkShakaPlayerStatus()
    
    // ---------------------------
// Updated Destroy Function
// ---------------------------
function destroyCurrent() {
    // Destroy Shaka Player instance
    if (currentShaka) {
        try {
            currentShaka.destroy();
            currentShaka = null;
        } catch(e) {
            console.error('Error destroying Shaka player:', e);
        }
    }
    
    // Existing destruction code
    if (currentHls) {
        try { currentHls.destroy(); } catch(e){}
        currentHls = null;
    }
    if (currentVideo) {
        try { 
            currentVideo.pause();
            currentVideo.src = ""; 
            currentVideo.load(); 
            currentVideo.remove(); 
        } catch(e){}
        currentVideo = null;
    }
    
    // ‚úÖ HIDE CUSTOM CONTROLS
    if (customControls && customControls.hide) {
        customControls.hide();
    }
    if (currentVideo) {
        try { 
            currentVideo.pause();
            currentVideo.src = ""; 
            currentVideo.load(); 
            currentVideo.remove(); 
        } catch(e){}
        currentVideo = null;
    }
    const oldIframe = videoWrapper.querySelector('iframe');
    if (oldIframe) oldIframe.remove();
    qualitySelector.style.display = "none";
    qualitySelector.innerHTML = "";
    unmuteBtn.style.display = 'none';
}


    function loadYouTube(link) {
        destroyCurrent();
        showLoader(true);
        const iframe = document.createElement("iframe");
        iframe.src = link;
        iframe.allow = "autoplay; encrypted-media; fullscreen";
        iframe.frameBorder = "0";
        iframe.onload = () => { showLoader(false); };
        videoWrapper.appendChild(iframe);
        log('Loaded YouTube iframe');
    }

    function loadHls(link) {
        destroyCurrent();
        showLoader(true);

        const video = setupVideoElement();
        videoWrapper.appendChild(video);
        currentVideo = video;

        if (Hls.isSupported()) {
            const hls = new Hls({
                maxBufferLength: 30,
                maxMaxBufferLength: 60,
                enableWorker: true,
                lowLatencyMode: false,
                backBufferLength: 30
            });

            hls.loadSource(link);
            hls.attachMedia(video);

            hls.on(Hls.Events.MANIFEST_PARSED, function (event, data) {
                log("Available levels:", data.levels);

                if (data.levels && data.levels.length > 1) {
                    populateQualitySelector(hls, data.levels);
                } else {
                    qualitySelector.style.display = "none";
                }

                showLoader(false);
                video.play().catch(err => {
                    console.log('Autoplay prevented:', err);
                    unmuteBtn.style.display = 'block';
                });
            });

            hls.on(Hls.Events.ERROR, function (event, data) {
                log("HLS error:", data);
                if (data.fatal) {
                    switch (data.type) {
                        case Hls.ErrorTypes.NETWORK_ERROR:
                            log("fatal network error encountered, trying to recover");
                            hls.startLoad();
                            break;
                        case Hls.ErrorTypes.MEDIA_ERROR:
                            log("fatal media error encountered, trying to recover");
                            hls.recoverMediaError();
                            break;
                        default:
                            hls.destroy();
                            break;
                    }
                }
            });

            currentHls = hls;
        } else if (video.canPlayType("application/vnd.apple.mpegurl")) {
            // Safari native HLS support
            video.src = link;
            video.addEventListener("loadedmetadata", () => {
                video.play().catch(err => {
                    console.log('Autoplay prevented:', err);
                    unmuteBtn.style.display = 'block';
                });
            });
            showLoader(false);
        } else {
            log("HLS not supported in this browser");
            showLoader(false);
        }
    }


// ---------------------------
// Enhanced Controls Manager for DASH
// ---------------------------
const customControls = {
    init() {
        if (!document.getElementById('custom-controls')) {
            this.createControls();
        }
        
        this.controls = document.getElementById('custom-controls');
        this.liveIndicator = document.getElementById('live-indicator');
        this.fullscreenBtn = document.getElementById('fullscreen-btn');
        this.videoWrapper = document.getElementById('videoWrapper');
        
        this.setupEventListeners();
    },

    createControls() {
        const controlsHTML = `
            <div id="custom-controls" style="display: none;">
                <div id="live-indicator">‚óè LIVE</div>
                <button id="fullscreen-btn" title="Toggle Fullscreen (F)">‚õ∂</button>
            </div>
        `;
        document.getElementById('videoWrapper').insertAdjacentHTML('beforeend', controlsHTML);
    },

    setupEventListeners() {
        this.fullscreenBtn.addEventListener('click', () => {
            this.toggleFullscreen();
        });

        // Fullscreen change events
        document.addEventListener('fullscreenchange', this.handleFullscreenChange.bind(this));
        document.addEventListener('webkitfullscreenchange', this.handleFullscreenChange.bind(this));

        // Show controls on video wrapper interaction
        this.videoWrapper.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.videoWrapper.addEventListener('click', this.handleClick.bind(this));
    },

    handleMouseMove() {
        this.show();
        this.clearHideTimeout();
        this.hideTimeout = setTimeout(() => {
            if (!this.isFullscreen()) {
                this.hide();
            }
        }, 3000);
    },

    handleClick() {
        this.show();
        this.clearHideTimeout();
    },

    handleFullscreenChange() {
        if (this.isFullscreen()) {
            this.fullscreenBtn.innerHTML = '‚ßâ';
            this.fullscreenBtn.title = 'Exit Fullscreen (F)';
            this.show(); // Always show in fullscreen
        } else {
            this.fullscreenBtn.innerHTML = '‚õ∂';
            this.fullscreenBtn.title = 'Enter Fullscreen (F)';
            this.hide();
        }
    },

    clearHideTimeout() {
        if (this.hideTimeout) {
            clearTimeout(this.hideTimeout);
        }
    },

    show() {
        if (this.controls) {
            this.controls.style.display = 'flex';
            this.controls.style.opacity = '1';
        }
    },

    hide() {
        if (this.controls && !this.isFullscreen()) {
            this.controls.style.opacity = '0';
            setTimeout(() => {
                if (this.controls.style.opacity === '0') {
                    this.controls.style.display = 'none';
                }
            }, 300);
        }
    },

    toggleFullscreen() {
        if (!this.isFullscreen()) {
            this.enterFullscreen();
        } else {
            this.exitFullscreen();
        }
    },

    enterFullscreen() {
        const element = this.videoWrapper;
        if (element.requestFullscreen) {
            element.requestFullscreen();
        } else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
        } else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
        }
    },

    exitFullscreen() {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    },

    isFullscreen() {
        return !!(document.fullscreenElement || 
                 document.webkitFullscreenElement || 
                 document.msFullscreenElement);
    },

    setLiveIndicator(live) {
        if (this.liveIndicator) {
            if (live) {
                this.liveIndicator.style.display = 'block';
                this.liveIndicator.textContent = '‚óè LIVE';
                this.liveIndicator.style.background = 'rgba(255, 50, 50, 0.9)';
            } else {
                this.liveIndicator.style.display = 'none';
            }
        }
    },

    updateLiveDelay(delaySeconds) {
        if (this.liveIndicator && this.liveIndicator.style.display !== 'none') {
            if (delaySeconds <= 5) {
                this.liveIndicator.textContent = '‚óè LIVE';
                this.liveIndicator.style.background = 'rgba(255, 50, 50, 0.9)';
            } else if (delaySeconds <= 15) {
                this.liveIndicator.textContent = `LIVE -${Math.round(delaySeconds)}s`;
                this.liveIndicator.style.background = 'rgba(255, 165, 0, 0.9)';
            } else if (delaySeconds <= 30) {
                this.liveIndicator.textContent = `LIVE -${Math.round(delaySeconds)}s`;
                this.liveIndicator.style.background = 'rgba(255, 200, 0, 0.9)';
            } else {
                this.liveIndicator.textContent = `LIVE -${Math.round(delaySeconds)}s`;
                this.liveIndicator.style.background = 'rgba(0, 100, 255, 0.9)';
            }
        }
    }
};

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    customControls.init();
});



 // ---------------------------
// Optimized HLS for Slow Networks with Controls
// ---------------------------
function loadHlsOptimized(link) {
    destroyCurrent();
    showLoader(true);

    const video = setupVideoElement();
    videoWrapper.appendChild(video);
    currentVideo = video;

    // ‚úÖ Add class for custom controls
    video.classList.add('video-with-custom-controls');

    if (Hls.isSupported()) {
        const hls = new Hls({
            // ‚ö° Optimized for slow networks
            maxBufferLength: 30,           // Reduced buffer
            maxMaxBufferLength: 60,
            maxBufferSize: 30 * 1000 * 1000, // 30MB buffer max
            maxLoadingDelay: 4,            // Reduced delay
            lowLatencyMode: false,
            backBufferLength: 10,          // Reduced back buffer
            
            // üìä ABR settings
            enableWorker: true,
            abrEwmaDefaultEstimate: 500000, // Start with 500kbps
            abrEwmaSlowLive: 5.0,
            abrEwmaFastLive: 3.0,
            abrEwmaDefaultLive: 4.0,
            
            // üîß Performance
            stretchShortVideoTrack: true,
            maxFragLookUpTolerance: 0.1,
            liveSyncDurationCount: 2,       // Reduced for live
            liveMaxLatencyDurationCount: 5
        });

        hls.loadSource(link);
        hls.attachMedia(video);

        hls.on(Hls.Events.MANIFEST_PARSED, function (event, data) {
            console.log('‚úÖ HLS manifest parsed');
            
            // ‚úÖ SHOW CUSTOM CONTROLS
            customControls.show();
            
            // ‚úÖ DETECT LIVE STREAM
            const isLive = data.live || video.duration === Infinity;
            customControls.setLiveIndicator(isLive);
            
            // Force lower quality initially
            if (hls.levels.length > 1) {
                const suitableLevels = hls.levels.filter(level => 
                    level.height <= 480 && level.bitrate <= 1500000
                );
                
                if (suitableLevels.length > 0) {
                    const targetLevel = suitableLevels.reduce((prev, current) => 
                        (prev.bitrate > current.bitrate) ? prev : current
                    );
                    hls.currentLevel = targetLevel.level;
                    console.log(`üéØ Selected level: ${targetLevel.height}p @ ${Math.round(targetLevel.bitrate/1000)}kbps`);
                }
            }
            
            showLoader(false);
            handleAutoplayRestrictions(video);
        });

        // ‚úÖ UPDATE LIVE DELAY FOR LIVE STREAMS
        hls.on(Hls.Events.LEVEL_UPDATED, function (event, data) {
            if (data.details && data.details.live) {
                const delay = data.details.liveSyncDuration || data.details.targetduration * 3;
                customControls.updateLiveDelay(delay);
            }
        });

        // ‚úÖ UPDATE LIVE DELAY ON FRAGMENT LOADS
        hls.on(Hls.Events.FRAG_LOADED, function (event, data) {
            if (hls.levels[hls.currentLevel] && hls.levels[hls.currentLevel].details && hls.levels[hls.currentLevel].details.live) {
                const level = hls.levels[hls.currentLevel];
                const delay = level.details.liveSyncDuration || level.details.targetduration * 3;
                customControls.updateLiveDelay(delay);
            }
        });

        currentHls = hls;

    } else if (video.canPlayType("application/vnd.apple.mpegurl")) {
        // Safari native HLS
        video.src = link;
        video.addEventListener("loadedmetadata", () => {
            // ‚úÖ SHOW CUSTOM CONTROLS
            customControls.show();
            
            // ‚úÖ DETECT LIVE STREAM FOR SAFARI
            const isLive = video.duration === Infinity;
            customControls.setLiveIndicator(isLive);
            
            showLoader(false);
            handleAutoplayRestrictions(video);
        });

        // ‚úÖ UPDATE LIVE INDICATOR FOR SAFARI LIVE STREAMS
        video.addEventListener('timeupdate', () => {
            if (video.duration === Infinity) {
                // For Safari live streams, we can't get exact delay but show LIVE indicator
                customControls.setLiveIndicator(true);
            }
        });
    }

    // ‚úÖ ADD VIDEO EVENT LISTENERS FOR CONTROLS
    video.addEventListener('play', () => {
        customControls.show();
    });

    video.addEventListener('pause', () => {
        customControls.show();
    });

    video.addEventListener('ended', () => {
        customControls.show();
    });
}

    function loadDash(link, licenseData = null) {

    // ‚úÖ CORS proxy helper for CloudFront streams
    function getCorsProxiedUrl(url) {
        if (url.includes('cloudfront.net')) {
            console.log('‚ö†Ô∏è CloudFront URL detected, using CORS proxy');
            return 'https://corsproxy.io/?' + encodeURIComponent(url);
        }
        return url;
    }
    destroyCurrent();
    showLoader(true);

    const video = setupVideoElement();
    videoWrapper.appendChild(video);
    currentVideo = video;

    // Check if MediaSource is supported
    if (!dashjs.supportsMediaSource()) {
        console.error("MediaSource not supported");
        showLoader(false);
        channelName.textContent = `${channelName.textContent} - MediaSource not supported`;
        return;
    }

    try {
        console.log('üé¨ Initializing DASH player...');
        
        // ‚úÖ FIXED: Create DASH player with proper error handling
        const dash = dashjs.MediaPlayer().create();
        currentDash = dash;

        // ‚úÖ FIXED: Basic configuration first
        dash.updateSettings({
            streaming: {
                delay: {
                    liveDelay: 4
                },
                abr: {
                    autoSwitchBitrate: {
                        video: true,
                        audio: true
                    }
                },
                scheduleWhilePaused: false,
                fastSwitchEnabled: true
            },
            debug: {
                logLevel: dashjs.Debug.LOG_LEVEL_ERROR // Reduce verbosity
            }
        });

        // When you initialize:
         const proxiedLink = getCorsProxiedUrl(link);
         console.log("DASH: Initializing player with URL:", proxiedLink);
         dash.initialize(video, proxiedLink, true);

        // ‚úÖ FIXED: Safe event registration with null checks
        const safeOn = (eventType, handler) => {
            if (!eventType) {
                console.error('Cannot register event with null/undefined type');
                return;
            }
            try {
                dash.on(eventType, handler);
            } catch (error) {
                console.error(`Failed to register ${eventType} event:`, error);
            }
        };

        // ‚úÖ FIXED: Register events safely
        safeOn(dashjs.MediaPlayer.events.STREAM_INITIALIZED, function() {
    console.log("DASH: Stream initialized");
    showLoader(false);
    
    // ‚úÖ FIXED: Get bitrates after stream is initialized
    try {
        const bitrates = dash.getBitrateInfoListFor("video");
        if (bitrates && bitrates.length > 1) {
            populateDashQualitySelector(dash, bitrates);
        } else {
            qualitySelector.style.display = "none";
        }
    } catch (error) {
        console.warn('Could not get bitrates:', error);
        qualitySelector.style.display = "none";
    }

    safeOn(dashjs.MediaPlayer.events.ERROR, function(e) {
    console.error("DASH: Player error:", e);
    
    // Check if it's a CORS or network error but stream might still work
    if (e.error === "download" && e.event?.request?.status === 200) {
        console.log("DASH: Got 200 OK despite error, attempting to continue...");
        // Don't show loader, let it try to continue
        return;
    }

    
    showLoader(false);
});
});


        safeOn(dashjs.MediaPlayer.events.PLAYBACK_STARTED, function() {
            console.log("DASH: Playback started");
            showLoader(false);
        });

    safeOn(dashjs.MediaPlayer.events.ERROR, function(e) {
    console.error("DASH: Player error:", e);
    
    // Don't immediately stop on download errors - try to recover
    if (e.error && e.error.code === dashjs.MediaPlayer.errors.DOWNLOAD_ERROR_ID_MANIFEST_CODE) {
        console.log("DASH: Manifest download error, attempting recovery...");
        return; // Let retries handle it
    }
    
    // For segment errors, also try to recover
    if (e.error && (e.error.code === dashjs.MediaPlayer.errors.DOWNLOAD_ERROR_ID_SEGMENTS_CODE ||
                    e.error.code === dashjs.MediaPlayer.errors.DOWNLOAD_ERROR_ID_XLINK_CODE)) {
        console.log("DASH: Segment download error, attempting recovery...");
        return; // Let retries handle it
    }
    
    showLoader(false);
});

        // ‚úÖ FIXED: Set up DRM only if license data is provided and valid
        if (licenseData && licenseData.type === "clearkey") {
            try {
                const [keyId, keyValue] = licenseData.key.split(':');
                if (keyId && keyValue) {
                    const protectionData = {
                        "org.w3.clearkey": {
                            "clearkeys": {
                                [keyId]: keyValue
                            }
                        }
                    };
                    dash.setProtectionData(protectionData);
                    console.log('DASH: DRM configured with ClearKey');
                }
            } catch (drmError) {
                console.error('DASH: DRM setup error:', drmError);
            }
        }

        // ‚úÖ FIXED: Initialize with error handling
        console.log("DASH: Initializing player with URL:", link);
        dash.initialize(video, link, true);

// Helper function to setup quality selector
let qualitySelectorSetup = false;

const setupQualitySelector = () => {
    if (qualitySelectorSetup) return;
    
    try {
        // Verify dash player is ready
        if (!dash) {
            console.warn('DASH player not available');
            return;
        }
        
        // Check if method exists
        if (typeof dash.getBitrateInfoListFor !== 'function') {
            console.warn('getBitrateInfoListFor method not available');
            qualitySelector.style.display = "none";
            return;
        }
        
        const bitrates = dash.getBitrateInfoListFor("video");
        
        if (bitrates && bitrates.length > 1) {
            populateDashQualitySelector(dash, bitrates);
            qualitySelectorSetup = true;
            console.log('DASH: Quality selector populated with', bitrates.length, 'options');
        } else {
            console.log('DASH: Only one bitrate available');
            qualitySelector.style.display = "none";
        }
    } catch (error) {
        console.warn('Could not get bitrates:', error);
        qualitySelector.style.display = "none";
    }
};

// ‚úÖ Keep MANIFEST_LOADED but only for logging
safeOn(dashjs.MediaPlayer.events.MANIFEST_LOADED, function(e) {
    console.log("DASH: Manifest loaded successfully");
    // Don't setup quality selector here - too early!
});

// ‚úÖ Setup quality selector on STREAM_INITIALIZED
safeOn(dashjs.MediaPlayer.events.STREAM_INITIALIZED, function() {
    console.log("DASH: Stream initialized");
    showLoader(false);
    setTimeout(setupQualitySelector, 300); // Small delay to ensure bitrates are ready
});

// ‚úÖ Also try on PLAYBACK_STARTED as backup
safeOn(dashjs.MediaPlayer.events.PLAYBACK_STARTED, function() {
    console.log("DASH: Playback started");
    showLoader(false);
    setupQualitySelector(); // Try again if it didn't work earlier
});

        // Handle video events
        // In loadDash function:
video.addEventListener('loadedmetadata', () => {
    showLoader(false);
    handleAutoplayRestrictions(video); // ‚úÖ Use enhanced handler
            const playPromise = video.play();
            if (playPromise !== undefined) {
                playPromise.catch(err => {
                    console.log('DASH: Autoplay prevented:', err);
                    unmuteBtn.style.display = 'block';
                });
            }
        });

    } catch (error) {
        console.error('‚ùå Failed to initialize DASH player:', error);
        channelName.textContent = `${channelName.textContent} - DASH Error`;
        showLoader(false);
        
        // Final fallback: try HLS if DASH fails
        const hlsLink = link.replace('.mpd', '.m3u8');
        if (hlsLink !== link) {
            console.log("DASH: Trying HLS fallback...");
            loadHls(hlsLink);
        }
    }


    // Add after other event handlers
safeOn(dashjs.MediaPlayer.events.BUFFER_EMPTY, function(e) {
    console.warn("DASH: Buffer empty for", e.mediaType);
    showLoader(true);
});

safeOn(dashjs.MediaPlayer.events.BUFFER_LOADED, function(e) {
    console.log("DASH: Buffer loaded for", e.mediaType);
    showLoader(false);
});

// Detect playback stalls
let stallTimeout;
video.addEventListener('waiting', () => {
    console.warn("DASH: Video waiting/stalled");
    showLoader(true);
    
    // If stalled for more than 10 seconds, try to recover
    stallTimeout = setTimeout(() => {
        console.error("DASH: Stalled for 10s, attempting recovery...");
        if (currentDash) {
            try {
                const currentTime = video.currentTime;
                currentDash.reset();
                currentDash.attachSource(link);
                video.currentTime = currentTime;
            } catch (err) {
                console.error("DASH: Recovery failed:", err);
            }
        }
    }, 10000);
});

video.addEventListener('playing', () => {
    console.log("DASH: Video playing");
    clearTimeout(stallTimeout);
    showLoader(false);
});

    // ---------------------------
// Optimized DASH for Slow Networks
// ---------------------------
function loadDashOptimized(link, licenseData = null) {
    destroyCurrent();
    showLoader(true);

    const video = setupVideoElement();
    videoWrapper.appendChild(video);
    currentVideo = video;

    // Add class for custom controls
    video.classList.add('video-with-custom-controls');

    try {
        const dash = dashjs.MediaPlayer().create();
        currentDash = dash;

        dash.updateSettings({
    streaming: {
        delay: { 
            liveDelay: 8, // Increase delay for more buffer
            liveCatchUp: 0.05 // Slower catch-up
        },
        buffer: {
            bufferTimeAtTopQuality: 20, // Increase buffer
            bufferAheadToKeep: 20,
            bufferBehindToKeep: 10,
            stableBufferTime: 12, // ‚úÖ ADD: Time to buffer before starting
            bufferTimeDefault: 12 // ‚úÖ ADD: Default buffer time
        },
        abr: {
            autoSwitchBitrate: { video: true, audio: true },
            initialBitrate: { video: 500000 },
            maxBitrate: { video: 2500000 },
            maxRepresentationRatio: { video: 1 },
            bandwidthSafetyFactor: 0.9 // ‚úÖ ADD: More conservative bitrate selection
        },
        scheduleWhilePaused: false,
        fastSwitchEnabled: true,
        lowLatencyMode: false,
        retryIntervals: {
            MPD: 1000, // Increase retry interval
            XHRLoad: 2000,
            MediaSegment: 2000 // ‚úÖ ADD: Retry segments
        },
        retryAttempts: {
            MPD: 5, // More retry attempts
            XHRLoad: 5,
            MediaSegment: 5 // ‚úÖ ADD: Retry segments
        },
        xhr: {
            withCredentials: false
        },
        gaps: { // ‚úÖ ADD: Handle gaps in timeline
            jumpGaps: true,
            jumpLargeGaps: true,
            smallGapLimit: 1.5
        }
    },
    debug: {
        logLevel: dashjs.Debug.LOG_LEVEL_WARNING // Show warnings to debug
    }
});


        // ‚úÖ ENHANCED DASH EVENTS FOR CONTROLS
        dash.on(dashjs.MediaPlayer.events.MANIFEST_LOADED, function(e) {
            console.log("DASH: Manifest loaded");
            
            // ‚úÖ SHOW CONTROLS
            customControls.show();
            
            // ‚úÖ DETECT LIVE STREAM
            const isLive = dash.isDynamic();
            customControls.setLiveIndicator(isLive);
            
            console.log(`üìä DASH Stream Info: Live=${isLive}, Duration=${dash.duration()}`);
            
            showLoader(false);
        });

        dash.on(dashjs.MediaPlayer.events.STREAM_INITIALIZED, function() {
            console.log("DASH: Stream initialized");
        });

        // ‚úÖ UPDATE LIVE DELAY FOR DASH LIVE STREAMS
        let liveUpdateInterval;
        dash.on(dashjs.MediaPlayer.events.PLAYBACK_STARTED, function() {
            console.log("DASH: Playback started");
            
            if (dash.isDynamic()) {
                // Start updating live delay periodically
                liveUpdateInterval = setInterval(() => {
                    try {
                        const liveDelay = dash.getTargetLiveDelay();
                        const currentTime = dash.time();
                        const duration = dash.duration();
                        
                        customControls.updateLiveDelay(liveDelay);
                        
                        // Log live stream info for debugging
                        if (Math.random() < 0.01) { // Log occasionally to avoid spam
                            console.log(`üìä Live Stats: Delay=${liveDelay.toFixed(1)}s, Time=${currentTime.toFixed(1)}`);
                        }
                    } catch (error) {
                        console.log('Error updating live delay:', error);
                    }
                }, 1000); // Update every second
            }
        });

        // ‚úÖ HANDLE PLAYBACK ERRORS
        dash.on(dashjs.MediaPlayer.events.ERROR, function(e) {
            console.error("DASH: Player error", e);
            if (e.error && e.error.code === dashjs.MediaPlayer.errors.MANIFEST_LOADER_LOADING_FAILURE_ERROR) {
                console.log("DASH: Manifest loading failed");
            }
        });

        dash.on(dashjs.MediaPlayer.events.PLAYBACK_ERROR, function(e) {
            console.error("DASH: Playback error", e);
        });

        // ‚úÖ HANDLE QUALITY CHANGES
        dash.on(dashjs.MediaPlayer.events.QUALITY_CHANGE_REQUESTED, function(e) {
            console.log(`üéØ DASH: Quality change to ${e.mediaType} bitrate ${Math.round(e.newQuality/1000)}kbps`);
        });

        // ‚úÖ CLEAN UP ON PLAYBACK ENDED
        dash.on(dashjs.MediaPlayer.events.PLAYBACK_ENDED, function() {
            console.log("DASH: Playback ended");
            if (liveUpdateInterval) {
                clearInterval(liveUpdateInterval);
            }
        });

        // ‚úÖ INITIALIZE DASH PLAYER
        console.log("üé¨ Initializing DASH player...");
        dash.initialize(video, link, false); // Don't autoplay initially
        
        // ‚úÖ ADD VIDEO EVENT LISTENERS FOR CONTROLS
        video.addEventListener('loadeddata', () => {
            console.log("DASH: Video data loaded");
            
            // Try to play after a short delay
            setTimeout(() => {
                video.play().catch(err => {
                    console.log('DASH autoplay prevented:', err);
                });
            }, 500);
        });

        video.addEventListener('play', () => {
            customControls.show();
        });

        video.addEventListener('pause', () => {
            customControls.show();
        });

        video.addEventListener('ended', () => {
            customControls.show();
            if (liveUpdateInterval) {
                clearInterval(liveUpdateInterval);
            }
        });

        video.addEventListener('waiting', () => {
            console.log("DASH: Video waiting/buffering");
        });

        video.addEventListener('playing', () => {
            console.log("DASH: Video playing");
        });

        // ‚úÖ ADD KEYBOARD SHORTCUTS FOR DASH PLAYER
        video.addEventListener('keydown', (e) => {
            // F key for fullscreen
            if (e.key === 'f' || e.key === 'F') {
                e.preventDefault();
                customControls.toggleFullscreen();
            }
            
            // Space for play/pause
            if (e.key === ' ') {
                e.preventDefault();
                if (video.paused) {
                    video.play();
                } else {
                    video.pause();
                }
            }
        });

        // Make video focusable for keyboard controls
        video.setAttribute('tabindex', '0');

    } catch (error) {
        console.error('‚ùå DASH initialization failed:', error);
        showLoader(false);
        channelName.textContent = `${channelName.textContent} - DASH Error`;
        
        // ‚úÖ FALLBACK TO OTHER PLAYERS
        setTimeout(() => {
            console.log("üîÑ Trying fallback after DASH failure...");
            const fallbackData = { 
                name: channelName.textContent, 
                type: "mpd", 
                link: link 
            };
            handleStreamErrorFallback(fallbackData, error.message);
        }, 1000);
        }
    }
}



    // ---------------------------
    // Quality selector helpers
    // ---------------------------
    function populateQualitySelector(hls, levels) {
        qualitySelector.innerHTML = "";
        const autoOption = document.createElement("option");
        autoOption.value = "auto";
        autoOption.textContent = "Auto";
        qualitySelector.appendChild(autoOption);

        levels.forEach((level, i) => {
            const opt = document.createElement("option");
            opt.value = i;
            const height = level.height || 'Unknown';
            const bitrate = level.bitrate ? ` (${Math.round(level.bitrate/1000)}kbps)` : '';
            opt.textContent = `${height}p${bitrate}`;
            qualitySelector.appendChild(opt);
        });

        qualitySelector.style.display = "inline-block";

        qualitySelector.onchange = function () {
            if (this.value === "auto") {
                hls.currentLevel = -1;
            } else {
                hls.currentLevel = parseInt(this.value);
            }
        };
    }

    function populateDashQualitySelector(dash, bitrates) {
        qualitySelector.innerHTML = "";
        const autoOption = document.createElement("option");
        autoOption.value = "auto";
        autoOption.textContent = "Auto";
        qualitySelector.appendChild(autoOption);

        bitrates.forEach((bitrate, i) => {
            const opt = document.createElement("option");
            opt.value = i;
            const height = bitrate.height || 'Unknown';
            const bitrateText = bitrate.bitrate ? ` (${Math.round(bitrate.bitrate/1000)}kbps)` : '';
            opt.textContent = `${height}p${bitrateText}`;
            qualitySelector.appendChild(opt);
        });

        qualitySelector.style.display = "inline-block";

        qualitySelector.onchange = function () {
            try {
                if (this.value === "auto") {
                    dash.setQualityFor("video", -1);
                } else {
                    dash.setQualityFor("video", parseInt(this.value));
                }
            } catch (e) {
                console.warn('Could not change quality:', e);
            }
        };
    }


    // ---------------------------
// User Quality Selection
// ---------------------------
function populateOptimizedQualitySelector(hls, levels) {
    qualitySelector.innerHTML = "";
    
    // Group by resolution and select optimal bitrates
    const optimalLevels = levels.filter(level => 
        level.bitrate <= 2500000 && level.height <= 720
    ).sort((a, b) => a.height - b.height);
    
    const autoOption = document.createElement("option");
    autoOption.value = "auto";
    autoOption.textContent = "Auto (Recommended)";
    autoOption.selected = true;
    qualitySelector.appendChild(autoOption);

    optimalLevels.forEach((level, i) => {
        const opt = document.createElement("option");
        opt.value = i;
        const bitrateText = level.bitrate ? ` (${Math.round(level.bitrate/1000)}kbps)` : '';
        opt.textContent = `${level.height}p${bitrateText}`;
        
        // Recommend 480p for 3Mbps
        if (level.height === 480 && level.bitrate <= 1200000) {
            opt.textContent += ' ‚òÖ';
        }
        
        qualitySelector.appendChild(opt);
    });

    qualitySelector.style.display = "inline-block";
    qualitySelector.onchange = function () {
        if (this.value === "auto") {
            hls.currentLevel = -1;
        } else {
            hls.currentLevel = parseInt(this.value);
        }
    };
}

function formatTimeDisplay(currentTime, duration) {
    if (!isFinite(duration) || duration > 86400) {
        return 'LIVE';
    }
    
    const formatTime = (seconds) => {
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        
        if (hrs > 0) {
            return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        } else {
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
    };
    
    return `${formatTime(currentTime)} / ${formatTime(duration)}`;
}

    // ---------------------------
// Updated Load Channel Function
// ---------------------------
function loadChannel(channel) {
    if (!channel || !channel.type) return;
    
    channelName.textContent = channel.name;
    showLoader(true);

    try {
        if (channel.type === "youtube") {
            loadYouTube(channel.link);
        } else if (channel.type === "m3u8") {
            loadHls(channel.link);
        } else if (channel.type === "mpd") {
            // Use smart DRM loader for MPD files
            console.log(`Loading MPD with smart DRM: ${channel.name}`);
            loadStreamWithSmartDRM(channel);
        } else {
            throw new Error(`Unsupported stream type: ${channel.type}`);
        }
    } catch (error) {
        console.error('Error loading channel:', error);
        channelName.textContent = `${channel.name} - Error: ${error.message}`;
        showLoader(false);
    
    channelName.textContent = `${channelName.textContent} - Shaka Error`;
    
    // ‚úÖ IMPROVED: Better fallback logic
    if (streamData.link.includes('.mpd')) {
        console.log('üîÑ Falling back to DASH.js...');
        
        // Create a clean stream data object for DASH fallback
        const dashStream = {
            link: streamData.link,
            license: streamData.license || null
        };
        
        // Use setTimeout to avoid call stack issues
        setTimeout(() => {
            try {
                loadDash(dashStream.link, dashStream.license);
            } catch (dashError) {
                console.error('DASH fallback also failed:', dashError);
                // Final fallback to HLS
                const hlsLink = streamData.link.replace('.mpd', '.m3u8');
                if (hlsLink !== streamData.link) {
                    console.log('üîÑ Trying HLS fallback...');
                    loadHls(hlsLink);
                }
            }
        }, 100);
    }
}
}


// Helper function to format ClearKey keys
function formatClearKeyKeys(keys) {
    if (typeof keys === 'string') {
        // Assume "keyId:keyValue" format
        const [keyId, keyValue] = keys.split(':');
        return { [keyId]: keyValue };
    } else if (Array.isArray(keys)) {
        // Convert array to object
        const keyObj = {};
        keys.forEach(key => {
            if (key.keyId && key.key) {
                keyObj[key.keyId] = key.key;
            }
        });
        return keyObj;
    } else if (typeof keys === 'object') {
        return keys;
    }
    return {};
}

// Example usage in your DRM configuration:
//const clearkeyConfig = {
    //servers: {
   //     'org.w3.clearkey': 'data:application/json;base64,eyJrZXlzIjpbXSwidHlwZSI6InRlbXBvcmFyeSJ9'
   // },
  //  clearKeys: formatClearKeyKeys(channel.clearkey)
//};


function loadDashWithClearKey(link, clearkeyData) {
    destroyCurrent();
    showLoader(true);

    const video = setupVideoElement();
    videoWrapper.appendChild(video);
    currentVideo = video;

    try {
        const dash = dashjs.MediaPlayer().create();
        currentDash = dash;

        // Configure ClearKey for DASH.js
        if (clearkeyData) {
            const protectionData = {
                "org.w3.clearkey": {
                    "clearkeys": {}
                }
            };

            // Parse ClearKey data
            if (typeof clearkeyData === 'string') {
                const [keyId, keyValue] = clearkeyData.split(':');
                if (keyId && keyValue) {
                    protectionData["org.w3.clearkey"].clearkeys[keyId] = keyValue;
                }
            } else if (typeof clearkeyData === 'object') {
                protectionData["org.w3.clearkey"].clearkeys = { ...clearkeyData };
            }

            console.log('DASH.js ClearKey configuration:', protectionData);
            dash.setProtectionData(protectionData);
        }

        // Basic configuration
        dash.updateSettings({
            streaming: {
                fastSwitchEnabled: true,
                abr: { autoSwitchBitrate: true }
            }
        });

        // Event handlers
        dash.on(dashjs.MediaPlayer.events.MANIFEST_LOADED, () => {
            console.log("DASH: Manifest loaded with ClearKey");
            showLoader(false);
        });

        dash.on(dashjs.MediaPlayer.events.ERROR, (e) => {
            console.error("DASH: Error:", e);
            showLoader(false);
        });

        // Initialize
        dash.initialize(video, link, false);
        
        video.addEventListener('loadeddata', () => {
            video.play().catch(err => {
                console.log('Autoplay prevented:', err);
                unmuteBtn.style.display = 'block';
            });
        });

    } catch (error) {
        console.error('DASH with ClearKey failed:', error);
        showLoader(false);
        channelName.textContent = `${channelName.textContent} - DRM Error`;
    }
}


// ---------------------------
// Optimized for 3Mbps Network
// ---------------------------
function loadStreamOptimizedForSlowNetwork(streamData) {
    destroyCurrent();
    showLoader(true);

    try {
        const video = setupVideoElement();
        videoWrapper.appendChild(video);
        currentVideo = video;

        shaka.polyfill.installAll();
        const player = new shaka.Player();
        player.attach(video);
        currentShaka = player;

        // ‚úÖ OPTIMIZED CONFIGURATION FOR 3MBPS
        player.configure({
            streaming: {
                // ‚ö° CRITICAL: Reduce buffer sizes for slow connections
                bufferingGoal: 15,           // Reduced from 30 to 15 seconds
                rebufferingGoal: 1.5,        // Reduced from 2 to 1.5 seconds
                bufferBehind: 20,            // Reduced from 30 to 20 seconds
                
                // üîß Performance optimizations
                lowLatencyMode: false,       // Disable for better stability
                ignoreTextStreamFailures: true,
                inaccurateManifestTolerance: 0,
                
                // üìä ABR (Adaptive Bitrate) optimizations
                abr: {
                    enabled: true,
                    defaultBandwidthEstimate: 500000, // Start with 500kbps
                    restrictions: {
                        minBandwidth: 100000,   // 100kbps minimum
                        maxBandwidth: 2500000,  // 2.5Mbps maximum (below your 3Mbps limit)
                        minWidth: 320,          // Minimum 320p
                        maxWidth: 1280,         // Maximum 720p
                        minHeight: 240,
                        maxHeight: 720
                    },
                    switchInterval: 8,          // Less frequent quality switching
                    bandwidthUpgradeTarget: 0.85, // 85% buffer before upgrading
                    bandwidthDowngradeTarget: 0.9  // 90% buffer before downgrading
                },
                
                // üîÑ Retry configuration
                retryParameters: {
                    maxAttempts: 5,
                    baseDelay: 1000,
                    backoffFactor: 1.5,
                    fuzzFactor: 0.5,
                    timeout: 10000
                }
            },
            
            // üéØ Manifest configuration
            manifest: {
                dash: {
                    ignoreMinBufferTime: true,
                    autoCorrectDrift: true,
                    enableForcedSubtitles: false, // Disable to save bandwidth
                    ignoreEmptyAdaptationSet: true
                }
            },
            
            // üîí DRM configuration (if needed)
            drm: {
                retryParameters: {
                    maxAttempts: 3,
                    baseDelay: 2000
                }
            }
        });


        // Load the stream
         player.load(streamData.link);
        
        // üé™ Force lower quality initially
        setTimeout(() => {
            try {
                const tracks = player.getVariantTracks();
                // Prefer lower bitrate tracks (360p-480p)
                const suitableTracks = tracks.filter(track => 
                    track.height <= 480 && track.bandwidth <= 1500000
                );
                
                if (suitableTracks.length > 0) {
                    // Select the best track under 1.5Mbps
                    const selectedTrack = suitableTracks.reduce((prev, current) => 
                        (prev.bandwidth > current.bandwidth) ? prev : current
                    );
                    player.selectVariantTrack(selectedTrack, true);
                    console.log(`üéØ Selected optimized track: ${selectedTrack.height}p @ ${Math.round(selectedTrack.bandwidth/1000)}kbps`);
                }
            } catch (e) {
                console.log('Could not force quality selection');
            }
        }, 2000);

        showLoader(false);
        
        video.play().catch(err => {
            console.log('Autoplay prevented:', err);
            unmuteBtn.style.display = 'block';
        });

    } catch (error) {
        console.error('Stream loading failed:', error);
        showLoader(false);
        channelName.textContent = `${channelName.textContent} - Load Error`;
    }
}


function testClearKeyDRM() {
    console.group('üß™ Testing ClearKey DRM');
    
    // Test with a known ClearKey encrypted stream
    // Note: You'll need an actual ClearKey-encrypted stream for this to work
    const testStream = {
        name: "TEST: ClearKey DRM",
        type: "mpd",
        link: "https://example.com/clearkey-encrypted-stream.mpd", // Replace with actual URL
        clearkey: "12345678123456781234567812345678:abcdef0123456789abcdef0123456789"
    };
    
    console.log('Testing ClearKey DRM support...');
    checkClearKeySupport();
    
    console.log('Loading ClearKey protected stream...');
    loadShakaStreamWithClearKey(testStream);
    
    console.groupEnd();
}

// Run this in console: testClearKeyDRM()


function checkAllDRMSupport() {
    console.group('üîí DRM Support Overview');
    
    const drmSystems = [
        { name: 'ClearKey', keySystem: 'org.w3.clearkey' },
        { name: 'Widevine', keySystem: 'com.widevine.alpha' },
        { name: 'PlayReady', keySystem: 'com.microsoft.playready' }
    ];
    
    drmSystems.forEach(system => {
        if (navigator.requestMediaKeySystemAccess) {
            navigator.requestMediaKeySystemAccess(system.keySystem, [{
                initDataTypes: ['cenc'],
                audioCapabilities: [{ contentType: 'audio/mp4; codecs="mp4a.40.2"' }],
                videoCapabilities: [{ contentType: 'video/mp4; codecs="avc1.42E01E"' }]
            }]).then(() => {
                console.log(`‚úÖ ${system.name} supported`);
            }).catch(() => {
                console.log(`‚ùå ${system.name} not supported`);
            });
        } else {
            console.log(`‚ùå EME not supported - cannot check ${system.name}`);
        }
    });
    
    console.groupEnd();
}
// Run this in console: checkAllDRMSupport()

function checkEnhancedDRMSupport() {
    console.group('üîí Enhanced DRM Support Check');
    
    if (!navigator.requestMediaKeySystemAccess) {
        console.error('‚ùå EME (Encrypted Media Extensions) not supported');
        console.groupEnd();
        return { eme: false };
    }
    
    const support = {
        widevine: false,
        widevineHw: false,
        clearkey: false,
        playready: false
    };
    
    // Test Widevine (Software)
    const widevineSwConfig = [{
        initDataTypes: ['cenc'],
        audioCapabilities: [{
            contentType: 'audio/mp4; codecs="mp4a.40.2"',
            robustness: 'SW_SECURE_CRYPTO'
        }],
        videoCapabilities: [{
            contentType: 'video/mp4; codecs="avc1.42E01E"',
            robustness: 'SW_SECURE_CRYPTO'
        }],
        distinctiveIdentifier: 'optional',
        persistentState: 'optional',
        sessionTypes: ['temporary']
    }];
    
    // Test Widevine (Hardware)
    const widevineHwConfig = [{
        initDataTypes: ['cenc'],
        audioCapabilities: [{
            contentType: 'audio/mp4; codecs="mp4a.40.2"',
            robustness: 'HW_SECURE_CRYPTO'
        }],
        videoCapabilities: [{
            contentType: 'video/mp4; codecs="avc1.42E01E"',
            robustness: 'HW_SECURE_CRYPTO'
        }],
        distinctiveIdentifier: 'optional',
        persistentState: 'optional',
        sessionTypes: ['temporary']
    }];
    
    // Test ClearKey with different configurations
    const clearkeyConfigs = [
        // Config 1: Basic ClearKey
        [{
            initDataTypes: ['cenc'],
            audioCapabilities: [{ contentType: 'audio/mp4; codecs="mp4a.40.2"' }],
            videoCapabilities: [{ contentType: 'video/mp4; codecs="avc1.42E01E"' }]
        }],
        // Config 2: With keyids
        [{
            initDataTypes: ['keyids'],
            audioCapabilities: [{ contentType: 'audio/mp4; codecs="mp4a.40.2"' }],
            videoCapabilities: [{ contentType: 'video/mp4; codecs="avc1.42E01E"' }]
        }],
        // Config 3: Combined initDataTypes
        [{
            initDataTypes: ['cenc', 'keyids'],
            audioCapabilities: [{ contentType: 'audio/mp4; codecs="mp4a.40.2"' }],
            videoCapabilities: [{ contentType: 'video/mp4; codecs="avc1.42E01E"' }]
        }]
    ];
    
    // Test Widevine Software
    navigator.requestMediaKeySystemAccess('com.widevine.alpha', widevineSwConfig)
        .then(() => {
            support.widevine = true;
            console.log('‚úÖ Widevine SW_SECURE_CRYPTO: Supported');
        })
        .catch((e) => {
            console.log('‚ùå Widevine SW_SECURE_CRYPTO: Not Supported -', e.message);
        });
    
    // Test Widevine Hardware
    navigator.requestMediaKeySystemAccess('com.widevine.alpha', widevineHwConfig)
        .then(() => {
            support.widevineHw = true;
            console.log('‚úÖ Widevine HW_SECURE_CRYPTO: Supported');
        })
        .catch((e) => {
            console.log('‚ùå Widevine HW_SECURE_CRYPTO: Not Supported -', e.message);
        });
    
    // Test ClearKey with multiple configurations
    let clearkeyTested = 0;
    const testClearKey = (config, index) => {
        navigator.requestMediaKeySystemAccess('org.w3.clearkey', config)
            .then(() => {
                support.clearkey = true;
                console.log(`‚úÖ ClearKey: Supported (Config ${index + 1})`);
            })
            .catch((e) => {
                clearkeyTested++;
                console.log(`‚ùå ClearKey Config ${index + 1}: Failed -`, e.message);
                
                if (clearkeyTested === clearkeyConfigs.length && !support.clearkey) {
                    console.log('‚ùå ClearKey: Not supported with any configuration');
                }
            });
    };
    
    clearkeyConfigs.forEach((config, index) => {
        setTimeout(() => testClearKey(config, index), index * 100);
    });
    
    // Test PlayReady
    navigator.requestMediaKeySystemAccess('com.microsoft.playready', [{
        initDataTypes: ['cenc'],
        audioCapabilities: [{ contentType: 'audio/mp4; codecs="mp4a.40.2"' }],
        videoCapabilities: [{ contentType: 'video/mp4; codecs="avc1.42E01E"' }]
    }])
    .then(() => {
        support.playready = true;
        console.log('‚úÖ PlayReady: Supported');
    })
    .catch((e) => {
        console.log('‚ùå PlayReady: Not Supported -', e.message);
    });
    
    setTimeout(() => {
        console.log('üìä Final DRM Support Summary:', support);
        window.drmSupport = support; // Store globally for later use
        console.groupEnd();
    }, 1000);
    
    return support;
}

// Run this in console: checkEnhancedDRMSupport()

function checkDashJSVersion() {
    console.group('üîç DASH.js Version Check');
    
    if (typeof dashjs === 'undefined') {
        console.error('‚ùå DASH.js not loaded');
        console.groupEnd();
        return;
    }
    
    console.log('‚úÖ DASH.js version:', dashjs.Version || 'Unknown');
    console.log('‚úÖ MediaSource supported:', dashjs.supportsMediaSource());
    console.log('‚úÖ Events object:', dashjs.MediaPlayer.events);
    
    // Check if events are properly defined
    const essentialEvents = [
        'MANIFEST_LOADED',
        'PLAYBACK_ERROR', 
        'ERROR',
        'STREAM_INITIALIZED'
    ];
    
    essentialEvents.forEach(eventName => {
        const eventValue = dashjs.MediaPlayer.events[eventName];
        console.log(`Event ${eventName}:`, eventValue ? '‚úÖ Defined' : '‚ùå Undefined');
    });
    
    console.groupEnd();
}

// Run this in console: checkDashJSVersion()


function parseClearKeyData(clearkeyData) {
    if (typeof clearkeyData === 'string') {
        const [keyId, keyValue] = clearkeyData.split(':');
        return keyId && keyValue ? { [keyId]: keyValue } : {};
    } else if (Array.isArray(clearkeyData)) {
        const keys = {};
        clearkeyData.forEach(key => {
            if (key.keyId && key.key) keys[key.keyId] = key.key;
        });
        return keys;
    } else if (typeof clearkeyData === 'object') {
        return { ...clearkeyData };
    }
    return {};
}


// ---------------------------
// Handle autoplay restrictions
// ---------------------------
function handleAutoplayRestrictions(video) {
    const playPromise = video.play();
    
    if (playPromise !== undefined) {
        playPromise.catch(error => {
            console.log('üîá Autoplay was prevented:', error.name);
            
            // Show a subtle message to the user
            const autoplayMessage = document.createElement('div');
            autoplayMessage.style.cssText = `
                position: absolute;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 8px 16px;
                border-radius: 4px;
                font-size: 14px;
                z-index: 1000;
            `;
            autoplayMessage.textContent = 'Click the video to play';
            video.parentNode.appendChild(autoplayMessage);
            
            // Remove message after 3 seconds
            setTimeout(() => {
                if (autoplayMessage.parentNode) {
                    autoplayMessage.remove();
                }
            }, 3000);
            
            // Allow manual play on click
            video.addEventListener('click', function playOnClick() {
                video.play().then(() => {
                    video.removeEventListener('click', playOnClick);
                    if (autoplayMessage.parentNode) {
                        autoplayMessage.remove();
                    }
                });
            }, { once: true });
        });
    }
}


function handleDRMFallback(streamData, error) {
    console.log('üîÑ Handling DRM fallback...');
    showLoader(false);
    
    // Fallback strategies
    if (streamData.link.includes('.mpd')) {
        if (error.code === 4032 || error.code === 6001) {
            // DRM license error - try without DRM
            console.log('üîì Trying without DRM...');
            const fallbackData = { ...streamData };
            delete fallbackData.licenseServer;
            delete fallbackData.clearkey;
            delete fallbackData.drmType;
            
            setTimeout(() => loadDash(fallbackData.link), 500);
        } else {
            // Other error - try DASH.js
            console.log('üîÑ Falling back to DASH.js...');
            loadDash(streamData.link, streamData.clearkey);
        }
    } else {
        channelName.textContent = `${channelName.textContent} - Playback Failed`;
    }
}


// ---------------------------
// Initialize when page loads
// ---------------------------
document.addEventListener('DOMContentLoaded', function() {
    console.log('Page loaded, initializing player...');
    console.log('DashJS available:', typeof dashjs !== 'undefined');
    console.log('HLS.js available:', typeof Hls !== 'undefined');
    console.log('Shaka Player available:', typeof shaka !== 'undefined');
    
    checkDRMSupport();
    initializeChannels();
});


// ---------------------------
// Wait for all resources to load
// ---------------------------
window.addEventListener('load', function() {
    console.log('üìÑ All page resources loaded');
    
    // If channels aren't initialized yet, do it now
    if (!window.channelsInitialized) {
        setTimeout(() => {
            initializeChannels();
        }, 100);
    }
});

// Also keep your DOMContentLoaded for faster initial load
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ DOM loaded, starting initialization...');
    window.channelsInitialized = true;
    initializeChannels();
});


function checkCodecSupport() {
    console.group('üîç Codec Support Check');
    
    const video = document.createElement('video');
    const codecs = [
        'video/mp4; codecs="avc1.42E01E"',
        'video/mp4; codecs="avc1.42801E"',
        'video/mp4; codecs="avc1.640028"',
        'video/mp4; codecs="hev1.1.6.L93.B0"',
        'video/mp4; codecs="hvc1.1.6.L93.B0"',
        'video/webm; codecs="vp9"',
        'video/webm; codecs="vp8"',
        'audio/mp4; codecs="mp4a.40.2"',
        'audio/mp4; codecs="mp4a.40.5"',
        'audio/webm; codecs="opus"'
    ];
    
    codecs.forEach(codec => {
        const isSupported = video.canPlayType(codec);
        console.log(`${codec}: ${isSupported}`);
    });
    
    console.groupEnd();
}

// Call this in your DOMContentLoaded
checkCodecSupport();

// Keep all your existing functions (loadHls, loadDash, loadYouTube, etc.) as they are
// Only the functions above need to be added/modified
  </script>
</body>
</html>
